{"version":3,"file":"popup.js","mappings":";;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACnIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AEvBA;AACA;AACA;AACA","sources":["webpack://ai-dictionary-plus/./src/popup/index.tsx","webpack://ai-dictionary-plus/./src/shared/types.ts","webpack://ai-dictionary-plus/./src/shared/utils.ts","webpack://ai-dictionary-plus/webpack/bootstrap","webpack://ai-dictionary-plus/webpack/before-startup","webpack://ai-dictionary-plus/webpack/startup","webpack://ai-dictionary-plus/webpack/after-startup"],"sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"../shared/utils\");\n// Initialize when the DOM is loaded\ndocument.addEventListener('DOMContentLoaded', () => __awaiter(void 0, void 0, void 0, function* () {\n    // Apply theme\n    const settings = yield (0, utils_1.getSettings)();\n    applyTheme(settings);\n    // Check API key\n    checkApiKey(settings.apiKey);\n    // Set up event listeners\n    setupEventListeners();\n}));\n// Apply theme based on settings\nfunction applyTheme(settings) {\n    const theme = (0, utils_1.getTheme)(settings);\n    if (theme === 'dark') {\n        document.body.classList.add('dark-theme');\n    }\n    else {\n        document.body.classList.remove('dark-theme');\n    }\n}\n// Check if API key is set\nfunction checkApiKey(apiKey) {\n    const statusElement = document.getElementById('apiKeyStatus');\n    if (!statusElement)\n        return;\n    if (!apiKey) {\n        statusElement.textContent = 'API Key is not set. Please set it in the options.';\n        statusElement.classList.add('error');\n    }\n    else {\n        statusElement.textContent = 'API Key is set âœ“';\n        statusElement.classList.remove('error');\n    }\n}\n// Setup event listeners\nfunction setupEventListeners() {\n    // Options button\n    const optionsBtn = document.getElementById('optionsBtn');\n    if (optionsBtn) {\n        optionsBtn.addEventListener('click', (e) => {\n            e.preventDefault();\n            chrome.runtime.openOptionsPage();\n        });\n    }\n    // Chat button\n    const chatBtn = document.getElementById('chatBtn');\n    if (chatBtn) {\n        chatBtn.addEventListener('click', (e) => {\n            e.preventDefault();\n            const chatUrl = chrome.runtime.getURL('chat.html');\n            chrome.tabs.create({ url: chatUrl });\n        });\n    }\n}\n","\"use strict\";\n// Type definitions for the extension\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MessageType = exports.DEFAULT_SETTINGS = void 0;\n// Default settings\nexports.DEFAULT_SETTINGS = {\n    apiKey: \"\",\n    perplexityApiKey: \"\",\n    theme: \"auto\",\n    maxTokens: 1000,\n    cacheEnabled: true,\n    cacheExpiry: 24,\n    webSearchEnabled: true,\n    keyboardShortcut: {\n        key: \"E\",\n        ctrlKey: false,\n        shiftKey: true,\n        altKey: false,\n        metaKey: true, // Cmd key on Mac\n    },\n};\n// Message types for communication between components\nvar MessageType;\n(function (MessageType) {\n    MessageType[\"EXPLAIN_TEXT\"] = \"EXPLAIN_TEXT\";\n    MessageType[\"EXPLANATION_RESULT\"] = \"EXPLANATION_RESULT\";\n    MessageType[\"FOLLOW_UP_QUESTION\"] = \"FOLLOW_UP_QUESTION\";\n    MessageType[\"WEB_SEARCH\"] = \"WEB_SEARCH\";\n    MessageType[\"WEB_SEARCH_RESULT\"] = \"WEB_SEARCH_RESULT\";\n    MessageType[\"OPEN_CHAT\"] = \"OPEN_CHAT\";\n    MessageType[\"GET_SETTINGS\"] = \"GET_SETTINGS\";\n    MessageType[\"SAVE_SETTINGS\"] = \"SAVE_SETTINGS\";\n    MessageType[\"SETTINGS_UPDATED\"] = \"SETTINGS_UPDATED\";\n    MessageType[\"ERROR\"] = \"ERROR\";\n})(MessageType || (exports.MessageType = MessageType = {}));\n","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isValidText = exports.generateCacheKey = exports.clearExpiredCache = exports.getCacheItem = exports.setCacheItem = exports.saveSettings = exports.getSettings = exports.getTheme = exports.getSystemTheme = void 0;\nexports.debounce = debounce;\n/// <reference types=\"chrome\" />\nconst types_1 = require(\"./types\");\n// Get current system theme (light or dark)\nconst getSystemTheme = () => {\n    return window.matchMedia &&\n        window.matchMedia(\"(prefers-color-scheme: dark)\").matches\n        ? \"dark\"\n        : \"light\";\n};\nexports.getSystemTheme = getSystemTheme;\n// Determine theme based on settings\nconst getTheme = (settings) => {\n    if (settings.theme === \"auto\") {\n        return (0, exports.getSystemTheme)();\n    }\n    return settings.theme;\n};\nexports.getTheme = getTheme;\n// Get settings from storage\nconst getSettings = () => __awaiter(void 0, void 0, void 0, function* () {\n    return new Promise((resolve) => {\n        chrome.storage.sync.get(\"settings\", (result) => {\n            // If no settings found, use defaults\n            if (!result.settings) {\n                resolve(Object.assign({}, types_1.DEFAULT_SETTINGS));\n                return;\n            }\n            // Merge saved settings with defaults to ensure all properties exist\n            const mergedSettings = Object.assign(Object.assign(Object.assign({}, types_1.DEFAULT_SETTINGS), result.settings), { \n                // Handle nested objects like keyboardShortcut\n                keyboardShortcut: Object.assign(Object.assign({}, types_1.DEFAULT_SETTINGS.keyboardShortcut), (result.settings.keyboardShortcut || {})) });\n            resolve(mergedSettings);\n        });\n    });\n});\nexports.getSettings = getSettings;\n// Save settings to storage\nconst saveSettings = (settings) => __awaiter(void 0, void 0, void 0, function* () {\n    return new Promise((resolve) => {\n        chrome.storage.sync.set({ settings }, () => {\n            resolve();\n        });\n    });\n});\nexports.saveSettings = saveSettings;\n// Set an item in the cache\nconst setCacheItem = (key, data, expiryHours) => __awaiter(void 0, void 0, void 0, function* () {\n    const cacheItem = {\n        data,\n        timestamp: Date.now() + expiryHours * 60 * 60 * 1000,\n    };\n    yield chrome.storage.local.set({ [key]: cacheItem });\n});\nexports.setCacheItem = setCacheItem;\n// Get an item from the cache\nconst getCacheItem = (key) => __awaiter(void 0, void 0, void 0, function* () {\n    return new Promise((resolve) => {\n        chrome.storage.local.get(key, (result) => {\n            const cacheItem = result[key];\n            // If no cache or expired\n            if (!cacheItem || Date.now() > cacheItem.timestamp) {\n                resolve(null);\n                return;\n            }\n            resolve(cacheItem.data);\n        });\n    });\n});\nexports.getCacheItem = getCacheItem;\n// Clear expired cache items\nconst clearExpiredCache = () => __awaiter(void 0, void 0, void 0, function* () {\n    const allCache = (yield chrome.storage.local.get(null));\n    const now = Date.now();\n    const keysToRemove = [];\n    for (const [key, value] of Object.entries(allCache)) {\n        const cacheValue = value;\n        if (key.startsWith(\"cache_\") &&\n            cacheValue.timestamp &&\n            cacheValue.timestamp < now) {\n            keysToRemove.push(key);\n        }\n    }\n    if (keysToRemove.length > 0) {\n        yield chrome.storage.local.remove(keysToRemove);\n    }\n});\nexports.clearExpiredCache = clearExpiredCache;\n// Generate a cache key from text\nconst generateCacheKey = (text) => {\n    // Simple hash function for strings\n    let hash = 0;\n    if (text.length === 0)\n        return \"cache_empty\";\n    for (let i = 0; i < text.length; i++) {\n        const char = text.charCodeAt(i);\n        hash = (hash << 5) - hash + char;\n        hash = hash & hash; // Convert to 32bit integer\n    }\n    return `cache_${hash}`;\n};\nexports.generateCacheKey = generateCacheKey;\n// Debounce function to prevent too many API calls\nfunction debounce(func, waitFor) {\n    let timeout = null;\n    return function (...args) {\n        if (timeout !== null) {\n            clearTimeout(timeout);\n        }\n        timeout = setTimeout(() => func(...args), waitFor);\n    };\n}\n// Function to check if the text is valid for an explanation\nconst isValidText = (text) => {\n    if (!text)\n        return false;\n    text = text.trim();\n    return text.length > 0 && text.length <= 1000; // Arbitrary limit to prevent large requests\n};\nexports.isValidText = isValidText;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./src/popup/index.tsx\");\n",""],"names":[],"sourceRoot":""}