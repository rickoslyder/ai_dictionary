{"version":3,"file":"popup.js","mappings":";;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACnGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AChLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC5LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AEvBA;AACA;AACA;AACA","sources":["webpack://ai-dictionary-plus/./src/popup/index.tsx","webpack://ai-dictionary-plus/./src/shared/db.ts","webpack://ai-dictionary-plus/./src/shared/types.ts","webpack://ai-dictionary-plus/./src/shared/utils.ts","webpack://ai-dictionary-plus/webpack/bootstrap","webpack://ai-dictionary-plus/webpack/before-startup","webpack://ai-dictionary-plus/webpack/startup","webpack://ai-dictionary-plus/webpack/after-startup"],"sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/// <reference types=\"chrome\" />\nconst types_1 = require(\"../shared/types\");\nconst utils_1 = require(\"../shared/utils\");\n// Initialize when the DOM is loaded\ndocument.addEventListener('DOMContentLoaded', () => __awaiter(void 0, void 0, void 0, function* () {\n    // Apply theme\n    const settings = yield (0, utils_1.getSettings)();\n    applyTheme(settings);\n    // Check API key\n    checkApiKey(settings.apiKey);\n    // Set up event listeners\n    setupEventListeners();\n}));\n// Apply theme based on settings\nfunction applyTheme(settings) {\n    const theme = (0, utils_1.getTheme)(settings);\n    if (theme === 'dark') {\n        document.body.classList.add('dark-theme');\n    }\n    else {\n        document.body.classList.remove('dark-theme');\n    }\n}\n// Check if API key is set\nfunction checkApiKey(apiKey) {\n    const statusElement = document.getElementById('apiKeyStatus');\n    if (!statusElement)\n        return;\n    if (!apiKey) {\n        statusElement.textContent = 'API Key is not set. Please set it in the options.';\n        statusElement.classList.add('error');\n    }\n    else {\n        statusElement.textContent = 'API Key is set âœ“';\n        statusElement.classList.remove('error');\n    }\n}\n// Setup event listeners\nfunction setupEventListeners() {\n    // Options button\n    const optionsBtn = document.getElementById('optionsBtn');\n    if (optionsBtn) {\n        optionsBtn.addEventListener('click', (e) => {\n            e.preventDefault();\n            chrome.runtime.openOptionsPage();\n        });\n    }\n    // Chat button\n    const chatBtn = document.getElementById('chatBtn');\n    if (chatBtn) {\n        chatBtn.addEventListener('click', (e) => __awaiter(this, void 0, void 0, function* () {\n            e.preventDefault();\n            // Get active tab info to provide context\n            const tabs = yield chrome.tabs.query({ active: true, currentWindow: true });\n            if (tabs.length > 0) {\n                const activeTab = tabs[0];\n                // Create chat data with context from active tab\n                const chatData = {\n                    originalText: activeTab.title || 'Current page',\n                    conversationHistory: []\n                };\n                // Encode data to pass via URL\n                const encodedData = encodeURIComponent(JSON.stringify(chatData));\n                const chatUrl = chrome.runtime.getURL(`chat.html?data=${encodedData}`);\n                // Notify background script (optional, for future use)\n                chrome.runtime.sendMessage({\n                    type: types_1.MessageType.OPEN_CHAT,\n                    payload: chatData,\n                });\n                // Open chat in new tab\n                chrome.tabs.create({ url: chatUrl });\n            }\n            else {\n                // Fallback if no active tab\n                const chatUrl = chrome.runtime.getURL('chat.html');\n                chrome.tabs.create({ url: chatUrl });\n            }\n        }));\n    }\n    // History button\n    const historyBtn = document.getElementById('historyBtn');\n    if (historyBtn) {\n        historyBtn.addEventListener('click', (e) => {\n            e.preventDefault();\n            const historyUrl = chrome.runtime.getURL('history.html');\n            chrome.tabs.create({ url: historyUrl });\n        });\n    }\n}\n","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DatabaseError = void 0;\nexports.initDatabase = initDatabase;\nexports.addHistoryEntry = addHistoryEntry;\nexports.getHistoryEntry = getHistoryEntry;\nexports.getAllHistoryEntries = getAllHistoryEntries;\nexports.clearOldHistoryEntries = clearOldHistoryEntries;\nexports.getHistoryEntriesInRange = getHistoryEntriesInRange;\nexports.searchHistoryEntries = searchHistoryEntries;\nconst DB_NAME = \"ai_dictionary_plus\";\nconst DB_VERSION = 1;\nconst HISTORY_STORE = \"history\";\nconst SETTINGS_STORE = \"settings\";\nclass DatabaseError extends Error {\n    constructor(message) {\n        super(message);\n        this.name = \"DatabaseError\";\n    }\n}\nexports.DatabaseError = DatabaseError;\nfunction initDatabase() {\n    return __awaiter(this, void 0, void 0, function* () {\n        return new Promise((resolve, reject) => {\n            const request = indexedDB.open(DB_NAME, DB_VERSION);\n            request.onerror = () => {\n                reject(new DatabaseError(\"Failed to open database\"));\n            };\n            request.onsuccess = () => {\n                resolve(request.result);\n            };\n            request.onupgradeneeded = (event) => {\n                const db = event.target.result;\n                // Create history store with indexes\n                if (!db.objectStoreNames.contains(HISTORY_STORE)) {\n                    const historyStore = db.createObjectStore(HISTORY_STORE, {\n                        keyPath: \"id\",\n                    });\n                    historyStore.createIndex(\"timestamp\", \"timestamp\");\n                    historyStore.createIndex(\"text\", \"text\");\n                    historyStore.createIndex(\"pageUrl\", \"pageUrl\");\n                }\n                // Create settings store\n                if (!db.objectStoreNames.contains(SETTINGS_STORE)) {\n                    db.createObjectStore(SETTINGS_STORE);\n                }\n            };\n        });\n    });\n}\n// Add a history entry\nfunction addHistoryEntry(entry) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const db = yield initDatabase();\n        return new Promise((resolve, reject) => {\n            const transaction = db.transaction(HISTORY_STORE, \"readwrite\");\n            const store = transaction.objectStore(HISTORY_STORE);\n            const request = store.add(entry);\n            request.onerror = () => {\n                reject(new DatabaseError(\"Failed to add history entry\"));\n            };\n            request.onsuccess = () => {\n                resolve();\n            };\n        });\n    });\n}\n// Get a history entry by ID\nfunction getHistoryEntry(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const db = yield initDatabase();\n        return new Promise((resolve, reject) => {\n            const transaction = db.transaction(HISTORY_STORE, \"readonly\");\n            const store = transaction.objectStore(HISTORY_STORE);\n            const request = store.get(id);\n            request.onerror = () => {\n                reject(new DatabaseError(\"Failed to get history entry\"));\n            };\n            request.onsuccess = () => {\n                resolve(request.result || null);\n            };\n        });\n    });\n}\n// Get all history entries\nfunction getAllHistoryEntries() {\n    return __awaiter(this, void 0, void 0, function* () {\n        const db = yield initDatabase();\n        return new Promise((resolve, reject) => {\n            const transaction = db.transaction(HISTORY_STORE, \"readonly\");\n            const store = transaction.objectStore(HISTORY_STORE);\n            const request = store.getAll();\n            request.onerror = () => {\n                reject(new DatabaseError(\"Failed to get history entries\"));\n            };\n            request.onsuccess = () => {\n                resolve(request.result);\n            };\n        });\n    });\n}\n// Clear history entries older than the specified date\nfunction clearOldHistoryEntries(cutoffTime) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const db = yield initDatabase();\n        return new Promise((resolve, reject) => {\n            const transaction = db.transaction(HISTORY_STORE, \"readwrite\");\n            const store = transaction.objectStore(HISTORY_STORE);\n            const index = store.index(\"timestamp\");\n            // Use a cursor to iterate through old entries\n            const range = IDBKeyRange.upperBound(cutoffTime);\n            const request = index.openCursor(range);\n            request.onerror = () => {\n                reject(new DatabaseError(\"Failed to clear old history entries\"));\n            };\n            request.onsuccess = (event) => {\n                const cursor = event.target.result;\n                if (cursor) {\n                    store.delete(cursor.primaryKey);\n                    cursor.continue();\n                }\n                else {\n                    resolve();\n                }\n            };\n        });\n    });\n}\n// Get history entries within a date range\nfunction getHistoryEntriesInRange(startTime, endTime) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const db = yield initDatabase();\n        return new Promise((resolve, reject) => {\n            const transaction = db.transaction(HISTORY_STORE, \"readonly\");\n            const store = transaction.objectStore(HISTORY_STORE);\n            const index = store.index(\"timestamp\");\n            const range = IDBKeyRange.bound(startTime, endTime);\n            const request = index.getAll(range);\n            request.onerror = () => {\n                reject(new DatabaseError(\"Failed to get history entries in range\"));\n            };\n            request.onsuccess = () => {\n                resolve(request.result);\n            };\n        });\n    });\n}\n// Search history entries by text\nfunction searchHistoryEntries(searchText) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const db = yield initDatabase();\n        return new Promise((resolve, reject) => {\n            const transaction = db.transaction(HISTORY_STORE, \"readonly\");\n            const store = transaction.objectStore(HISTORY_STORE);\n            const request = store.getAll();\n            request.onerror = () => {\n                reject(new DatabaseError(\"Failed to search history entries\"));\n            };\n            request.onsuccess = () => {\n                const entries = request.result;\n                const searchLower = searchText.toLowerCase();\n                const results = entries.filter((entry) => entry.text.toLowerCase().includes(searchLower) ||\n                    entry.explanation.toLowerCase().includes(searchLower));\n                resolve(results);\n            };\n        });\n    });\n}\n","\"use strict\";\n// Type definitions for the extension\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MessageType = exports.MediaType = exports.DEFAULT_SETTINGS = void 0;\n// Default settings\nexports.DEFAULT_SETTINGS = {\n    apiKey: \"\",\n    perplexityApiKey: \"\",\n    theme: \"auto\",\n    maxTokens: 2000,\n    cacheEnabled: true,\n    cacheExpiry: 24,\n    webSearchEnabled: true,\n    keyboardShortcut: {\n        key: \"E\",\n        ctrlKey: false,\n        shiftKey: true,\n        altKey: false,\n        metaKey: true, // Cmd key on Mac\n    },\n    multimodalEnabled: true,\n    historyRetention: 7, // Default to 7 days\n};\n// Media types supported by the extension\nvar MediaType;\n(function (MediaType) {\n    MediaType[\"TEXT\"] = \"text\";\n    MediaType[\"IMAGE\"] = \"image\";\n    MediaType[\"DOCUMENT\"] = \"document\";\n    MediaType[\"AUDIO\"] = \"audio\";\n    MediaType[\"VIDEO\"] = \"video\";\n})(MediaType || (exports.MediaType = MediaType = {}));\n// Message types for communication between components\nvar MessageType;\n(function (MessageType) {\n    MessageType[\"EXPLAIN_TEXT\"] = \"EXPLAIN_TEXT\";\n    MessageType[\"EXPLANATION_RESULT\"] = \"EXPLANATION_RESULT\";\n    MessageType[\"FOLLOW_UP_QUESTION\"] = \"FOLLOW_UP_QUESTION\";\n    MessageType[\"WEB_SEARCH\"] = \"WEB_SEARCH\";\n    MessageType[\"WEB_SEARCH_RESULT\"] = \"WEB_SEARCH_RESULT\";\n    MessageType[\"OPEN_CHAT\"] = \"OPEN_CHAT\";\n    MessageType[\"GET_SETTINGS\"] = \"GET_SETTINGS\";\n    MessageType[\"SAVE_SETTINGS\"] = \"SAVE_SETTINGS\";\n    MessageType[\"SETTINGS_UPDATED\"] = \"SETTINGS_UPDATED\";\n    MessageType[\"ERROR\"] = \"ERROR\";\n    // New message types for multimedia\n    MessageType[\"EXPLAIN_MEDIA\"] = \"EXPLAIN_MEDIA\";\n    MessageType[\"MEDIA_EXPLANATION_RESULT\"] = \"MEDIA_EXPLANATION_RESULT\";\n    // New message type for multimodal content (text + media combined)\n    MessageType[\"EXPLAIN_MULTIMODAL\"] = \"EXPLAIN_MULTIMODAL\";\n})(MessageType || (exports.MessageType = MessageType = {}));\n","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isValidText = exports.generateCacheKey = exports.clearExpiredCache = exports.getCacheItem = exports.setCacheItem = exports.cleanupHistoryEntries = exports.getHistoryLogEntry = exports.addHistoryLogEntry = exports.getHistoryLog = exports.HISTORY_LOG_KEY = exports.saveSettings = exports.getSettings = exports.getTheme = exports.getSystemTheme = void 0;\nexports.debounce = debounce;\n/// <reference types=\"chrome\" />\nconst types_1 = require(\"./types\");\nconst db_1 = require(\"./db\");\n// Get current system theme (light or dark)\nconst getSystemTheme = () => {\n    return window.matchMedia &&\n        window.matchMedia(\"(prefers-color-scheme: dark)\").matches\n        ? \"dark\"\n        : \"light\";\n};\nexports.getSystemTheme = getSystemTheme;\n// Determine theme based on settings\nconst getTheme = (settings) => {\n    if (settings.theme === \"auto\") {\n        return (0, exports.getSystemTheme)();\n    }\n    return settings.theme;\n};\nexports.getTheme = getTheme;\n// Get settings from storage\nconst getSettings = () => __awaiter(void 0, void 0, void 0, function* () {\n    return new Promise((resolve) => {\n        chrome.storage.sync.get(\"settings\", (result) => {\n            // If no settings found, use defaults\n            if (!result.settings) {\n                resolve(Object.assign({}, types_1.DEFAULT_SETTINGS));\n                return;\n            }\n            // Merge saved settings with defaults to ensure all properties exist\n            const mergedSettings = Object.assign(Object.assign(Object.assign({}, types_1.DEFAULT_SETTINGS), result.settings), { \n                // Handle nested objects like keyboardShortcut\n                keyboardShortcut: Object.assign(Object.assign({}, types_1.DEFAULT_SETTINGS.keyboardShortcut), (result.settings.keyboardShortcut || {})) });\n            resolve(mergedSettings);\n        });\n    });\n});\nexports.getSettings = getSettings;\n// Save settings to storage\nconst saveSettings = (settings) => __awaiter(void 0, void 0, void 0, function* () {\n    return new Promise((resolve) => {\n        chrome.storage.sync.set({ settings }, () => {\n            resolve();\n        });\n    });\n});\nexports.saveSettings = saveSettings;\n// History log functions\nexports.HISTORY_LOG_KEY = \"explanation_history\";\n// Get the history log\nconst getHistoryLog = () => __awaiter(void 0, void 0, void 0, function* () {\n    return new Promise((resolve) => {\n        chrome.storage.local.get(exports.HISTORY_LOG_KEY, (result) => {\n            const historyLog = result[exports.HISTORY_LOG_KEY];\n            if (!historyLog) {\n                // Initialize empty history log if it doesn't exist\n                const emptyLog = {\n                    entries: [],\n                    lastUpdated: Date.now(),\n                };\n                resolve(emptyLog);\n            }\n            else {\n                resolve(historyLog);\n            }\n        });\n    });\n});\nexports.getHistoryLog = getHistoryLog;\n// Add an entry to the history log\nconst addHistoryLogEntry = (entry) => __awaiter(void 0, void 0, void 0, function* () {\n    // Generate a unique ID\n    const id = `hist_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    // Create the full entry\n    const fullEntry = Object.assign(Object.assign({}, entry), { id, timestamp: Date.now() });\n    // Add to IndexedDB\n    yield (0, db_1.addHistoryEntry)(fullEntry);\n    return id;\n});\nexports.addHistoryLogEntry = addHistoryLogEntry;\n// Get a history log entry by ID\nconst getHistoryLogEntry = (id) => __awaiter(void 0, void 0, void 0, function* () {\n    return (0, db_1.getHistoryEntry)(id);\n});\nexports.getHistoryLogEntry = getHistoryLogEntry;\n// Clear entries based on retention settings\nconst cleanupHistoryEntries = (settings) => __awaiter(void 0, void 0, void 0, function* () {\n    // If retention is set to 'forever', don't clean up\n    if (settings.historyRetention === \"forever\") {\n        return;\n    }\n    // Calculate cutoff time based on retention days\n    const cutoffTime = Date.now() - settings.historyRetention * 24 * 60 * 60 * 1000;\n    // Clear old entries\n    yield (0, db_1.clearOldHistoryEntries)(cutoffTime);\n});\nexports.cleanupHistoryEntries = cleanupHistoryEntries;\n// Set an item in the cache with history log reference\nconst setCacheItem = (key, data, expiryHours, historyLogId) => __awaiter(void 0, void 0, void 0, function* () {\n    const cacheItem = {\n        data,\n        timestamp: Date.now() + expiryHours * 60 * 60 * 1000,\n        historyLogId,\n    };\n    yield chrome.storage.local.set({ [key]: cacheItem });\n});\nexports.setCacheItem = setCacheItem;\n// Get an item from the cache and its history log entry if available\nconst getCacheItem = (key) => __awaiter(void 0, void 0, void 0, function* () {\n    return new Promise((resolve) => {\n        chrome.storage.local.get(key, (result) => __awaiter(void 0, void 0, void 0, function* () {\n            const cacheItem = result[key];\n            // If no cache or expired\n            if (!cacheItem || Date.now() > cacheItem.timestamp) {\n                resolve({ data: null, historyEntry: null });\n                return;\n            }\n            // Get history entry if available\n            let historyEntry = null;\n            if (cacheItem.historyLogId) {\n                historyEntry = yield (0, exports.getHistoryLogEntry)(cacheItem.historyLogId);\n            }\n            resolve({ data: cacheItem.data, historyEntry });\n        }));\n    });\n});\nexports.getCacheItem = getCacheItem;\n// Clear expired cache items\nconst clearExpiredCache = () => __awaiter(void 0, void 0, void 0, function* () {\n    const allCache = (yield chrome.storage.local.get(null));\n    const now = Date.now();\n    const keysToRemove = [];\n    for (const [key, value] of Object.entries(allCache)) {\n        const cacheValue = value;\n        if (key.startsWith(\"cache_\") &&\n            cacheValue.timestamp &&\n            cacheValue.timestamp < now) {\n            keysToRemove.push(key);\n        }\n    }\n    if (keysToRemove.length > 0) {\n        yield chrome.storage.local.remove(keysToRemove);\n    }\n});\nexports.clearExpiredCache = clearExpiredCache;\n// Generate a cache key from text\nconst generateCacheKey = (text) => {\n    // Simple hash function for strings\n    let hash = 0;\n    if (text.length === 0)\n        return \"cache_empty\";\n    for (let i = 0; i < text.length; i++) {\n        const char = text.charCodeAt(i);\n        hash = (hash << 5) - hash + char;\n        hash = hash & hash; // Convert to 32bit integer\n    }\n    return `cache_${hash}`;\n};\nexports.generateCacheKey = generateCacheKey;\n// Debounce function to prevent too many API calls\nfunction debounce(func, waitFor) {\n    let timeout = null;\n    return function (...args) {\n        if (timeout !== null) {\n            clearTimeout(timeout);\n        }\n        timeout = setTimeout(() => func(...args), waitFor);\n    };\n}\n// Function to check if the text is valid for an explanation\nconst isValidText = (text) => {\n    if (!text)\n        return false;\n    text = text.trim();\n    return text.length > 0 && text.length <= 1000; // Arbitrary limit to prevent large requests\n};\nexports.isValidText = isValidText;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./src/popup/index.tsx\");\n",""],"names":[],"sourceRoot":""}