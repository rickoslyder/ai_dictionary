/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/marked/lib/marked.cjs":
/*!********************************************!*\
  !*** ./node_modules/marked/lib/marked.cjs ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports) => {

/**
 * marked v9.1.6 - a markdown parser
 * Copyright (c) 2011-2023, Christopher Jeffrey. (MIT Licensed)
 * https://github.com/markedjs/marked
 */

/**
 * DO NOT EDIT THIS FILE
 * The code in this file is generated from files in ./src/
 */



/**
 * Gets the original marked default options.
 */
function _getDefaults() {
    return {
        async: false,
        breaks: false,
        extensions: null,
        gfm: true,
        hooks: null,
        pedantic: false,
        renderer: null,
        silent: false,
        tokenizer: null,
        walkTokens: null
    };
}
exports.defaults = _getDefaults();
function changeDefaults(newDefaults) {
    exports.defaults = newDefaults;
}

/**
 * Helpers
 */
const escapeTest = /[&<>"']/;
const escapeReplace = new RegExp(escapeTest.source, 'g');
const escapeTestNoEncode = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/;
const escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, 'g');
const escapeReplacements = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;'
};
const getEscapeReplacement = (ch) => escapeReplacements[ch];
function escape(html, encode) {
    if (encode) {
        if (escapeTest.test(html)) {
            return html.replace(escapeReplace, getEscapeReplacement);
        }
    }
    else {
        if (escapeTestNoEncode.test(html)) {
            return html.replace(escapeReplaceNoEncode, getEscapeReplacement);
        }
    }
    return html;
}
const unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;
function unescape(html) {
    // explicitly match decimal, hex, and named HTML entities
    return html.replace(unescapeTest, (_, n) => {
        n = n.toLowerCase();
        if (n === 'colon')
            return ':';
        if (n.charAt(0) === '#') {
            return n.charAt(1) === 'x'
                ? String.fromCharCode(parseInt(n.substring(2), 16))
                : String.fromCharCode(+n.substring(1));
        }
        return '';
    });
}
const caret = /(^|[^\[])\^/g;
function edit(regex, opt) {
    regex = typeof regex === 'string' ? regex : regex.source;
    opt = opt || '';
    const obj = {
        replace: (name, val) => {
            val = typeof val === 'object' && 'source' in val ? val.source : val;
            val = val.replace(caret, '$1');
            regex = regex.replace(name, val);
            return obj;
        },
        getRegex: () => {
            return new RegExp(regex, opt);
        }
    };
    return obj;
}
function cleanUrl(href) {
    try {
        href = encodeURI(href).replace(/%25/g, '%');
    }
    catch (e) {
        return null;
    }
    return href;
}
const noopTest = { exec: () => null };
function splitCells(tableRow, count) {
    // ensure that every cell-delimiting pipe has a space
    // before it to distinguish it from an escaped pipe
    const row = tableRow.replace(/\|/g, (match, offset, str) => {
        let escaped = false;
        let curr = offset;
        while (--curr >= 0 && str[curr] === '\\')
            escaped = !escaped;
        if (escaped) {
            // odd number of slashes means | is escaped
            // so we leave it alone
            return '|';
        }
        else {
            // add space before unescaped |
            return ' |';
        }
    }), cells = row.split(/ \|/);
    let i = 0;
    // First/last cell in a row cannot be empty if it has no leading/trailing pipe
    if (!cells[0].trim()) {
        cells.shift();
    }
    if (cells.length > 0 && !cells[cells.length - 1].trim()) {
        cells.pop();
    }
    if (count) {
        if (cells.length > count) {
            cells.splice(count);
        }
        else {
            while (cells.length < count)
                cells.push('');
        }
    }
    for (; i < cells.length; i++) {
        // leading or trailing whitespace is ignored per the gfm spec
        cells[i] = cells[i].trim().replace(/\\\|/g, '|');
    }
    return cells;
}
/**
 * Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').
 * /c*$/ is vulnerable to REDOS.
 *
 * @param str
 * @param c
 * @param invert Remove suffix of non-c chars instead. Default falsey.
 */
function rtrim(str, c, invert) {
    const l = str.length;
    if (l === 0) {
        return '';
    }
    // Length of suffix matching the invert condition.
    let suffLen = 0;
    // Step left until we fail to match the invert condition.
    while (suffLen < l) {
        const currChar = str.charAt(l - suffLen - 1);
        if (currChar === c && !invert) {
            suffLen++;
        }
        else if (currChar !== c && invert) {
            suffLen++;
        }
        else {
            break;
        }
    }
    return str.slice(0, l - suffLen);
}
function findClosingBracket(str, b) {
    if (str.indexOf(b[1]) === -1) {
        return -1;
    }
    let level = 0;
    for (let i = 0; i < str.length; i++) {
        if (str[i] === '\\') {
            i++;
        }
        else if (str[i] === b[0]) {
            level++;
        }
        else if (str[i] === b[1]) {
            level--;
            if (level < 0) {
                return i;
            }
        }
    }
    return -1;
}

function outputLink(cap, link, raw, lexer) {
    const href = link.href;
    const title = link.title ? escape(link.title) : null;
    const text = cap[1].replace(/\\([\[\]])/g, '$1');
    if (cap[0].charAt(0) !== '!') {
        lexer.state.inLink = true;
        const token = {
            type: 'link',
            raw,
            href,
            title,
            text,
            tokens: lexer.inlineTokens(text)
        };
        lexer.state.inLink = false;
        return token;
    }
    return {
        type: 'image',
        raw,
        href,
        title,
        text: escape(text)
    };
}
function indentCodeCompensation(raw, text) {
    const matchIndentToCode = raw.match(/^(\s+)(?:```)/);
    if (matchIndentToCode === null) {
        return text;
    }
    const indentToCode = matchIndentToCode[1];
    return text
        .split('\n')
        .map(node => {
        const matchIndentInNode = node.match(/^\s+/);
        if (matchIndentInNode === null) {
            return node;
        }
        const [indentInNode] = matchIndentInNode;
        if (indentInNode.length >= indentToCode.length) {
            return node.slice(indentToCode.length);
        }
        return node;
    })
        .join('\n');
}
/**
 * Tokenizer
 */
class _Tokenizer {
    options;
    // TODO: Fix this rules type
    rules;
    lexer;
    constructor(options) {
        this.options = options || exports.defaults;
    }
    space(src) {
        const cap = this.rules.block.newline.exec(src);
        if (cap && cap[0].length > 0) {
            return {
                type: 'space',
                raw: cap[0]
            };
        }
    }
    code(src) {
        const cap = this.rules.block.code.exec(src);
        if (cap) {
            const text = cap[0].replace(/^ {1,4}/gm, '');
            return {
                type: 'code',
                raw: cap[0],
                codeBlockStyle: 'indented',
                text: !this.options.pedantic
                    ? rtrim(text, '\n')
                    : text
            };
        }
    }
    fences(src) {
        const cap = this.rules.block.fences.exec(src);
        if (cap) {
            const raw = cap[0];
            const text = indentCodeCompensation(raw, cap[3] || '');
            return {
                type: 'code',
                raw,
                lang: cap[2] ? cap[2].trim().replace(this.rules.inline._escapes, '$1') : cap[2],
                text
            };
        }
    }
    heading(src) {
        const cap = this.rules.block.heading.exec(src);
        if (cap) {
            let text = cap[2].trim();
            // remove trailing #s
            if (/#$/.test(text)) {
                const trimmed = rtrim(text, '#');
                if (this.options.pedantic) {
                    text = trimmed.trim();
                }
                else if (!trimmed || / $/.test(trimmed)) {
                    // CommonMark requires space before trailing #s
                    text = trimmed.trim();
                }
            }
            return {
                type: 'heading',
                raw: cap[0],
                depth: cap[1].length,
                text,
                tokens: this.lexer.inline(text)
            };
        }
    }
    hr(src) {
        const cap = this.rules.block.hr.exec(src);
        if (cap) {
            return {
                type: 'hr',
                raw: cap[0]
            };
        }
    }
    blockquote(src) {
        const cap = this.rules.block.blockquote.exec(src);
        if (cap) {
            const text = rtrim(cap[0].replace(/^ *>[ \t]?/gm, ''), '\n');
            const top = this.lexer.state.top;
            this.lexer.state.top = true;
            const tokens = this.lexer.blockTokens(text);
            this.lexer.state.top = top;
            return {
                type: 'blockquote',
                raw: cap[0],
                tokens,
                text
            };
        }
    }
    list(src) {
        let cap = this.rules.block.list.exec(src);
        if (cap) {
            let bull = cap[1].trim();
            const isordered = bull.length > 1;
            const list = {
                type: 'list',
                raw: '',
                ordered: isordered,
                start: isordered ? +bull.slice(0, -1) : '',
                loose: false,
                items: []
            };
            bull = isordered ? `\\d{1,9}\\${bull.slice(-1)}` : `\\${bull}`;
            if (this.options.pedantic) {
                bull = isordered ? bull : '[*+-]';
            }
            // Get next list item
            const itemRegex = new RegExp(`^( {0,3}${bull})((?:[\t ][^\\n]*)?(?:\\n|$))`);
            let raw = '';
            let itemContents = '';
            let endsWithBlankLine = false;
            // Check if current bullet point can start a new List Item
            while (src) {
                let endEarly = false;
                if (!(cap = itemRegex.exec(src))) {
                    break;
                }
                if (this.rules.block.hr.test(src)) { // End list if bullet was actually HR (possibly move into itemRegex?)
                    break;
                }
                raw = cap[0];
                src = src.substring(raw.length);
                let line = cap[2].split('\n', 1)[0].replace(/^\t+/, (t) => ' '.repeat(3 * t.length));
                let nextLine = src.split('\n', 1)[0];
                let indent = 0;
                if (this.options.pedantic) {
                    indent = 2;
                    itemContents = line.trimStart();
                }
                else {
                    indent = cap[2].search(/[^ ]/); // Find first non-space char
                    indent = indent > 4 ? 1 : indent; // Treat indented code blocks (> 4 spaces) as having only 1 indent
                    itemContents = line.slice(indent);
                    indent += cap[1].length;
                }
                let blankLine = false;
                if (!line && /^ *$/.test(nextLine)) { // Items begin with at most one blank line
                    raw += nextLine + '\n';
                    src = src.substring(nextLine.length + 1);
                    endEarly = true;
                }
                if (!endEarly) {
                    const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ \t][^\\n]*)?(?:\\n|$))`);
                    const hrRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`);
                    const fencesBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\`\`\`|~~~)`);
                    const headingBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`);
                    // Check if following lines should be included in List Item
                    while (src) {
                        const rawLine = src.split('\n', 1)[0];
                        nextLine = rawLine;
                        // Re-align to follow commonmark nesting rules
                        if (this.options.pedantic) {
                            nextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, '  ');
                        }
                        // End list item if found code fences
                        if (fencesBeginRegex.test(nextLine)) {
                            break;
                        }
                        // End list item if found start of new heading
                        if (headingBeginRegex.test(nextLine)) {
                            break;
                        }
                        // End list item if found start of new bullet
                        if (nextBulletRegex.test(nextLine)) {
                            break;
                        }
                        // Horizontal rule found
                        if (hrRegex.test(src)) {
                            break;
                        }
                        if (nextLine.search(/[^ ]/) >= indent || !nextLine.trim()) { // Dedent if possible
                            itemContents += '\n' + nextLine.slice(indent);
                        }
                        else {
                            // not enough indentation
                            if (blankLine) {
                                break;
                            }
                            // paragraph continuation unless last line was a different block level element
                            if (line.search(/[^ ]/) >= 4) { // indented code block
                                break;
                            }
                            if (fencesBeginRegex.test(line)) {
                                break;
                            }
                            if (headingBeginRegex.test(line)) {
                                break;
                            }
                            if (hrRegex.test(line)) {
                                break;
                            }
                            itemContents += '\n' + nextLine;
                        }
                        if (!blankLine && !nextLine.trim()) { // Check if current line is blank
                            blankLine = true;
                        }
                        raw += rawLine + '\n';
                        src = src.substring(rawLine.length + 1);
                        line = nextLine.slice(indent);
                    }
                }
                if (!list.loose) {
                    // If the previous item ended with a blank line, the list is loose
                    if (endsWithBlankLine) {
                        list.loose = true;
                    }
                    else if (/\n *\n *$/.test(raw)) {
                        endsWithBlankLine = true;
                    }
                }
                let istask = null;
                let ischecked;
                // Check for task list items
                if (this.options.gfm) {
                    istask = /^\[[ xX]\] /.exec(itemContents);
                    if (istask) {
                        ischecked = istask[0] !== '[ ] ';
                        itemContents = itemContents.replace(/^\[[ xX]\] +/, '');
                    }
                }
                list.items.push({
                    type: 'list_item',
                    raw,
                    task: !!istask,
                    checked: ischecked,
                    loose: false,
                    text: itemContents,
                    tokens: []
                });
                list.raw += raw;
            }
            // Do not consume newlines at end of final item. Alternatively, make itemRegex *start* with any newlines to simplify/speed up endsWithBlankLine logic
            list.items[list.items.length - 1].raw = raw.trimEnd();
            list.items[list.items.length - 1].text = itemContents.trimEnd();
            list.raw = list.raw.trimEnd();
            // Item child tokens handled here at end because we needed to have the final item to trim it first
            for (let i = 0; i < list.items.length; i++) {
                this.lexer.state.top = false;
                list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);
                if (!list.loose) {
                    // Check if list should be loose
                    const spacers = list.items[i].tokens.filter(t => t.type === 'space');
                    const hasMultipleLineBreaks = spacers.length > 0 && spacers.some(t => /\n.*\n/.test(t.raw));
                    list.loose = hasMultipleLineBreaks;
                }
            }
            // Set all items to loose if list is loose
            if (list.loose) {
                for (let i = 0; i < list.items.length; i++) {
                    list.items[i].loose = true;
                }
            }
            return list;
        }
    }
    html(src) {
        const cap = this.rules.block.html.exec(src);
        if (cap) {
            const token = {
                type: 'html',
                block: true,
                raw: cap[0],
                pre: cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style',
                text: cap[0]
            };
            return token;
        }
    }
    def(src) {
        const cap = this.rules.block.def.exec(src);
        if (cap) {
            const tag = cap[1].toLowerCase().replace(/\s+/g, ' ');
            const href = cap[2] ? cap[2].replace(/^<(.*)>$/, '$1').replace(this.rules.inline._escapes, '$1') : '';
            const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline._escapes, '$1') : cap[3];
            return {
                type: 'def',
                tag,
                raw: cap[0],
                href,
                title
            };
        }
    }
    table(src) {
        const cap = this.rules.block.table.exec(src);
        if (cap) {
            if (!/[:|]/.test(cap[2])) {
                // delimiter row must have a pipe (|) or colon (:) otherwise it is a setext heading
                return;
            }
            const item = {
                type: 'table',
                raw: cap[0],
                header: splitCells(cap[1]).map(c => {
                    return { text: c, tokens: [] };
                }),
                align: cap[2].replace(/^\||\| *$/g, '').split('|'),
                rows: cap[3] && cap[3].trim() ? cap[3].replace(/\n[ \t]*$/, '').split('\n') : []
            };
            if (item.header.length === item.align.length) {
                let l = item.align.length;
                let i, j, k, row;
                for (i = 0; i < l; i++) {
                    const align = item.align[i];
                    if (align) {
                        if (/^ *-+: *$/.test(align)) {
                            item.align[i] = 'right';
                        }
                        else if (/^ *:-+: *$/.test(align)) {
                            item.align[i] = 'center';
                        }
                        else if (/^ *:-+ *$/.test(align)) {
                            item.align[i] = 'left';
                        }
                        else {
                            item.align[i] = null;
                        }
                    }
                }
                l = item.rows.length;
                for (i = 0; i < l; i++) {
                    item.rows[i] = splitCells(item.rows[i], item.header.length).map(c => {
                        return { text: c, tokens: [] };
                    });
                }
                // parse child tokens inside headers and cells
                // header child tokens
                l = item.header.length;
                for (j = 0; j < l; j++) {
                    item.header[j].tokens = this.lexer.inline(item.header[j].text);
                }
                // cell child tokens
                l = item.rows.length;
                for (j = 0; j < l; j++) {
                    row = item.rows[j];
                    for (k = 0; k < row.length; k++) {
                        row[k].tokens = this.lexer.inline(row[k].text);
                    }
                }
                return item;
            }
        }
    }
    lheading(src) {
        const cap = this.rules.block.lheading.exec(src);
        if (cap) {
            return {
                type: 'heading',
                raw: cap[0],
                depth: cap[2].charAt(0) === '=' ? 1 : 2,
                text: cap[1],
                tokens: this.lexer.inline(cap[1])
            };
        }
    }
    paragraph(src) {
        const cap = this.rules.block.paragraph.exec(src);
        if (cap) {
            const text = cap[1].charAt(cap[1].length - 1) === '\n'
                ? cap[1].slice(0, -1)
                : cap[1];
            return {
                type: 'paragraph',
                raw: cap[0],
                text,
                tokens: this.lexer.inline(text)
            };
        }
    }
    text(src) {
        const cap = this.rules.block.text.exec(src);
        if (cap) {
            return {
                type: 'text',
                raw: cap[0],
                text: cap[0],
                tokens: this.lexer.inline(cap[0])
            };
        }
    }
    escape(src) {
        const cap = this.rules.inline.escape.exec(src);
        if (cap) {
            return {
                type: 'escape',
                raw: cap[0],
                text: escape(cap[1])
            };
        }
    }
    tag(src) {
        const cap = this.rules.inline.tag.exec(src);
        if (cap) {
            if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {
                this.lexer.state.inLink = true;
            }
            else if (this.lexer.state.inLink && /^<\/a>/i.test(cap[0])) {
                this.lexer.state.inLink = false;
            }
            if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
                this.lexer.state.inRawBlock = true;
            }
            else if (this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
                this.lexer.state.inRawBlock = false;
            }
            return {
                type: 'html',
                raw: cap[0],
                inLink: this.lexer.state.inLink,
                inRawBlock: this.lexer.state.inRawBlock,
                block: false,
                text: cap[0]
            };
        }
    }
    link(src) {
        const cap = this.rules.inline.link.exec(src);
        if (cap) {
            const trimmedUrl = cap[2].trim();
            if (!this.options.pedantic && /^</.test(trimmedUrl)) {
                // commonmark requires matching angle brackets
                if (!(/>$/.test(trimmedUrl))) {
                    return;
                }
                // ending angle bracket cannot be escaped
                const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), '\\');
                if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
                    return;
                }
            }
            else {
                // find closing parenthesis
                const lastParenIndex = findClosingBracket(cap[2], '()');
                if (lastParenIndex > -1) {
                    const start = cap[0].indexOf('!') === 0 ? 5 : 4;
                    const linkLen = start + cap[1].length + lastParenIndex;
                    cap[2] = cap[2].substring(0, lastParenIndex);
                    cap[0] = cap[0].substring(0, linkLen).trim();
                    cap[3] = '';
                }
            }
            let href = cap[2];
            let title = '';
            if (this.options.pedantic) {
                // split pedantic href and title
                const link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);
                if (link) {
                    href = link[1];
                    title = link[3];
                }
            }
            else {
                title = cap[3] ? cap[3].slice(1, -1) : '';
            }
            href = href.trim();
            if (/^</.test(href)) {
                if (this.options.pedantic && !(/>$/.test(trimmedUrl))) {
                    // pedantic allows starting angle bracket without ending angle bracket
                    href = href.slice(1);
                }
                else {
                    href = href.slice(1, -1);
                }
            }
            return outputLink(cap, {
                href: href ? href.replace(this.rules.inline._escapes, '$1') : href,
                title: title ? title.replace(this.rules.inline._escapes, '$1') : title
            }, cap[0], this.lexer);
        }
    }
    reflink(src, links) {
        let cap;
        if ((cap = this.rules.inline.reflink.exec(src))
            || (cap = this.rules.inline.nolink.exec(src))) {
            let link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
            link = links[link.toLowerCase()];
            if (!link) {
                const text = cap[0].charAt(0);
                return {
                    type: 'text',
                    raw: text,
                    text
                };
            }
            return outputLink(cap, link, cap[0], this.lexer);
        }
    }
    emStrong(src, maskedSrc, prevChar = '') {
        let match = this.rules.inline.emStrong.lDelim.exec(src);
        if (!match)
            return;
        // _ can't be between two alphanumerics. \p{L}\p{N} includes non-english alphabet/numbers as well
        if (match[3] && prevChar.match(/[\p{L}\p{N}]/u))
            return;
        const nextChar = match[1] || match[2] || '';
        if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {
            // unicode Regex counts emoji as 1 char; spread into array for proper count (used multiple times below)
            const lLength = [...match[0]].length - 1;
            let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;
            const endReg = match[0][0] === '*' ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
            endReg.lastIndex = 0;
            // Clip maskedSrc to same section of string as src (move to lexer?)
            maskedSrc = maskedSrc.slice(-1 * src.length + lLength);
            while ((match = endReg.exec(maskedSrc)) != null) {
                rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];
                if (!rDelim)
                    continue; // skip single * in __abc*abc__
                rLength = [...rDelim].length;
                if (match[3] || match[4]) { // found another Left Delim
                    delimTotal += rLength;
                    continue;
                }
                else if (match[5] || match[6]) { // either Left or Right Delim
                    if (lLength % 3 && !((lLength + rLength) % 3)) {
                        midDelimTotal += rLength;
                        continue; // CommonMark Emphasis Rules 9-10
                    }
                }
                delimTotal -= rLength;
                if (delimTotal > 0)
                    continue; // Haven't found enough closing delimiters
                // Remove extra characters. *a*** -> *a*
                rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
                // char length can be >1 for unicode characters;
                const lastCharLength = [...match[0]][0].length;
                const raw = src.slice(0, lLength + match.index + lastCharLength + rLength);
                // Create `em` if smallest delimiter has odd char count. *a***
                if (Math.min(lLength, rLength) % 2) {
                    const text = raw.slice(1, -1);
                    return {
                        type: 'em',
                        raw,
                        text,
                        tokens: this.lexer.inlineTokens(text)
                    };
                }
                // Create 'strong' if smallest delimiter has even char count. **a***
                const text = raw.slice(2, -2);
                return {
                    type: 'strong',
                    raw,
                    text,
                    tokens: this.lexer.inlineTokens(text)
                };
            }
        }
    }
    codespan(src) {
        const cap = this.rules.inline.code.exec(src);
        if (cap) {
            let text = cap[2].replace(/\n/g, ' ');
            const hasNonSpaceChars = /[^ ]/.test(text);
            const hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);
            if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
                text = text.substring(1, text.length - 1);
            }
            text = escape(text, true);
            return {
                type: 'codespan',
                raw: cap[0],
                text
            };
        }
    }
    br(src) {
        const cap = this.rules.inline.br.exec(src);
        if (cap) {
            return {
                type: 'br',
                raw: cap[0]
            };
        }
    }
    del(src) {
        const cap = this.rules.inline.del.exec(src);
        if (cap) {
            return {
                type: 'del',
                raw: cap[0],
                text: cap[2],
                tokens: this.lexer.inlineTokens(cap[2])
            };
        }
    }
    autolink(src) {
        const cap = this.rules.inline.autolink.exec(src);
        if (cap) {
            let text, href;
            if (cap[2] === '@') {
                text = escape(cap[1]);
                href = 'mailto:' + text;
            }
            else {
                text = escape(cap[1]);
                href = text;
            }
            return {
                type: 'link',
                raw: cap[0],
                text,
                href,
                tokens: [
                    {
                        type: 'text',
                        raw: text,
                        text
                    }
                ]
            };
        }
    }
    url(src) {
        let cap;
        if (cap = this.rules.inline.url.exec(src)) {
            let text, href;
            if (cap[2] === '@') {
                text = escape(cap[0]);
                href = 'mailto:' + text;
            }
            else {
                // do extended autolink path validation
                let prevCapZero;
                do {
                    prevCapZero = cap[0];
                    cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];
                } while (prevCapZero !== cap[0]);
                text = escape(cap[0]);
                if (cap[1] === 'www.') {
                    href = 'http://' + cap[0];
                }
                else {
                    href = cap[0];
                }
            }
            return {
                type: 'link',
                raw: cap[0],
                text,
                href,
                tokens: [
                    {
                        type: 'text',
                        raw: text,
                        text
                    }
                ]
            };
        }
    }
    inlineText(src) {
        const cap = this.rules.inline.text.exec(src);
        if (cap) {
            let text;
            if (this.lexer.state.inRawBlock) {
                text = cap[0];
            }
            else {
                text = escape(cap[0]);
            }
            return {
                type: 'text',
                raw: cap[0],
                text
            };
        }
    }
}

/**
 * Block-Level Grammar
 */
// Not all rules are defined in the object literal
// @ts-expect-error
const block = {
    newline: /^(?: *(?:\n|$))+/,
    code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
    fences: /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
    hr: /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,
    heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
    blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
    list: /^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/,
    html: '^ {0,3}(?:' // optional indentation
        + '<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)' // (1)
        + '|comment[^\\n]*(\\n+|$)' // (2)
        + '|<\\?[\\s\\S]*?(?:\\?>\\n*|$)' // (3)
        + '|<![A-Z][\\s\\S]*?(?:>\\n*|$)' // (4)
        + '|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)' // (5)
        + '|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)' // (6)
        + '|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)' // (7) open tag
        + '|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)' // (7) closing tag
        + ')',
    def: /^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,
    table: noopTest,
    lheading: /^(?!bull )((?:.|\n(?!\s*?\n|bull ))+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
    // regex template, placeholders will be replaced according to different paragraph
    // interruption rules of commonmark and the original markdown spec:
    _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
    text: /^[^\n]+/
};
block._label = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
block.def = edit(block.def)
    .replace('label', block._label)
    .replace('title', block._title)
    .getRegex();
block.bullet = /(?:[*+-]|\d{1,9}[.)])/;
block.listItemStart = edit(/^( *)(bull) */)
    .replace('bull', block.bullet)
    .getRegex();
block.list = edit(block.list)
    .replace(/bull/g, block.bullet)
    .replace('hr', '\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))')
    .replace('def', '\\n+(?=' + block.def.source + ')')
    .getRegex();
block._tag = 'address|article|aside|base|basefont|blockquote|body|caption'
    + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption'
    + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe'
    + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option'
    + '|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr'
    + '|track|ul';
block._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
block.html = edit(block.html, 'i')
    .replace('comment', block._comment)
    .replace('tag', block._tag)
    .replace('attribute', / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/)
    .getRegex();
block.lheading = edit(block.lheading)
    .replace(/bull/g, block.bullet) // lists can interrupt
    .getRegex();
block.paragraph = edit(block._paragraph)
    .replace('hr', block.hr)
    .replace('heading', ' {0,3}#{1,6}(?:\\s|$)')
    .replace('|lheading', '') // setex headings don't interrupt commonmark paragraphs
    .replace('|table', '')
    .replace('blockquote', ' {0,3}>')
    .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n')
    .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
    .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)')
    .replace('tag', block._tag) // pars can be interrupted by type (6) html blocks
    .getRegex();
block.blockquote = edit(block.blockquote)
    .replace('paragraph', block.paragraph)
    .getRegex();
/**
 * Normal Block Grammar
 */
block.normal = { ...block };
/**
 * GFM Block Grammar
 */
block.gfm = {
    ...block.normal,
    table: '^ *([^\\n ].*)\\n' // Header
        + ' {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)' // Align
        + '(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)' // Cells
};
block.gfm.table = edit(block.gfm.table)
    .replace('hr', block.hr)
    .replace('heading', ' {0,3}#{1,6}(?:\\s|$)')
    .replace('blockquote', ' {0,3}>')
    .replace('code', ' {4}[^\\n]')
    .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n')
    .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
    .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)')
    .replace('tag', block._tag) // tables can be interrupted by type (6) html blocks
    .getRegex();
block.gfm.paragraph = edit(block._paragraph)
    .replace('hr', block.hr)
    .replace('heading', ' {0,3}#{1,6}(?:\\s|$)')
    .replace('|lheading', '') // setex headings don't interrupt commonmark paragraphs
    .replace('table', block.gfm.table) // interrupt paragraphs with table
    .replace('blockquote', ' {0,3}>')
    .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n')
    .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
    .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)')
    .replace('tag', block._tag) // pars can be interrupted by type (6) html blocks
    .getRegex();
/**
 * Pedantic grammar (original John Gruber's loose markdown specification)
 */
block.pedantic = {
    ...block.normal,
    html: edit('^ *(?:comment *(?:\\n|\\s*$)'
        + '|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)' // closed tag
        + '|<tag(?:"[^"]*"|\'[^\']*\'|\\s[^\'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))')
        .replace('comment', block._comment)
        .replace(/tag/g, '(?!(?:'
        + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub'
        + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)'
        + '\\b)\\w+(?!:|[^\\w\\s@]*@)\\b')
        .getRegex(),
    def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
    heading: /^(#{1,6})(.*)(?:\n+|$)/,
    fences: noopTest,
    lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
    paragraph: edit(block.normal._paragraph)
        .replace('hr', block.hr)
        .replace('heading', ' *#{1,6} *[^\n]')
        .replace('lheading', block.lheading)
        .replace('blockquote', ' {0,3}>')
        .replace('|fences', '')
        .replace('|list', '')
        .replace('|html', '')
        .getRegex()
};
/**
 * Inline-Level Grammar
 */
// Not all rules are defined in the object literal
// @ts-expect-error
const inline = {
    escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
    autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
    url: noopTest,
    tag: '^comment'
        + '|^</[a-zA-Z][\\w:-]*\\s*>' // self-closing tag
        + '|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>' // open tag
        + '|^<\\?[\\s\\S]*?\\?>' // processing instruction, e.g. <?php ?>
        + '|^<![a-zA-Z]+\\s[\\s\\S]*?>' // declaration, e.g. <!DOCTYPE html>
        + '|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>',
    link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
    reflink: /^!?\[(label)\]\[(ref)\]/,
    nolink: /^!?\[(ref)\](?:\[\])?/,
    reflinkSearch: 'reflink|nolink(?!\\()',
    emStrong: {
        lDelim: /^(?:\*+(?:((?!\*)[punct])|[^\s*]))|^_+(?:((?!_)[punct])|([^\s_]))/,
        //         (1) and (2) can only be a Right Delimiter. (3) and (4) can only be Left.  (5) and (6) can be either Left or Right.
        //         | Skip orphan inside strong      | Consume to delim | (1) #***              | (2) a***#, a***                    | (3) #***a, ***a                  | (4) ***#                 | (5) #***#                         | (6) a***a
        rDelimAst: /^[^_*]*?__[^_*]*?\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\*)[punct](\*+)(?=[\s]|$)|[^punct\s](\*+)(?!\*)(?=[punct\s]|$)|(?!\*)[punct\s](\*+)(?=[^punct\s])|[\s](\*+)(?!\*)(?=[punct])|(?!\*)[punct](\*+)(?!\*)(?=[punct])|[^punct\s](\*+)(?=[^punct\s])/,
        rDelimUnd: /^[^_*]*?\*\*[^_*]*?_[^_*]*?(?=\*\*)|[^_]+(?=[^_])|(?!_)[punct](_+)(?=[\s]|$)|[^punct\s](_+)(?!_)(?=[punct\s]|$)|(?!_)[punct\s](_+)(?=[^punct\s])|[\s](_+)(?!_)(?=[punct])|(?!_)[punct](_+)(?!_)(?=[punct])/ // ^- Not allowed for _
    },
    code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
    br: /^( {2,}|\\)\n(?!\s*$)/,
    del: noopTest,
    text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
    punctuation: /^((?![*_])[\spunctuation])/
};
// list of unicode punctuation marks, plus any missing characters from CommonMark spec
inline._punctuation = '\\p{P}$+<=>`^|~';
inline.punctuation = edit(inline.punctuation, 'u').replace(/punctuation/g, inline._punctuation).getRegex();
// sequences em should skip over [title](link), `code`, <html>
inline.blockSkip = /\[[^[\]]*?\]\([^\(\)]*?\)|`[^`]*?`|<[^<>]*?>/g;
inline.anyPunctuation = /\\[punct]/g;
inline._escapes = /\\([punct])/g;
inline._comment = edit(block._comment).replace('(?:-->|$)', '-->').getRegex();
inline.emStrong.lDelim = edit(inline.emStrong.lDelim, 'u')
    .replace(/punct/g, inline._punctuation)
    .getRegex();
inline.emStrong.rDelimAst = edit(inline.emStrong.rDelimAst, 'gu')
    .replace(/punct/g, inline._punctuation)
    .getRegex();
inline.emStrong.rDelimUnd = edit(inline.emStrong.rDelimUnd, 'gu')
    .replace(/punct/g, inline._punctuation)
    .getRegex();
inline.anyPunctuation = edit(inline.anyPunctuation, 'gu')
    .replace(/punct/g, inline._punctuation)
    .getRegex();
inline._escapes = edit(inline._escapes, 'gu')
    .replace(/punct/g, inline._punctuation)
    .getRegex();
inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
inline.autolink = edit(inline.autolink)
    .replace('scheme', inline._scheme)
    .replace('email', inline._email)
    .getRegex();
inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
inline.tag = edit(inline.tag)
    .replace('comment', inline._comment)
    .replace('attribute', inline._attribute)
    .getRegex();
inline._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
inline._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;
inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
inline.link = edit(inline.link)
    .replace('label', inline._label)
    .replace('href', inline._href)
    .replace('title', inline._title)
    .getRegex();
inline.reflink = edit(inline.reflink)
    .replace('label', inline._label)
    .replace('ref', block._label)
    .getRegex();
inline.nolink = edit(inline.nolink)
    .replace('ref', block._label)
    .getRegex();
inline.reflinkSearch = edit(inline.reflinkSearch, 'g')
    .replace('reflink', inline.reflink)
    .replace('nolink', inline.nolink)
    .getRegex();
/**
 * Normal Inline Grammar
 */
inline.normal = { ...inline };
/**
 * Pedantic Inline Grammar
 */
inline.pedantic = {
    ...inline.normal,
    strong: {
        start: /^__|\*\*/,
        middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
        endAst: /\*\*(?!\*)/g,
        endUnd: /__(?!_)/g
    },
    em: {
        start: /^_|\*/,
        middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
        endAst: /\*(?!\*)/g,
        endUnd: /_(?!_)/g
    },
    link: edit(/^!?\[(label)\]\((.*?)\)/)
        .replace('label', inline._label)
        .getRegex(),
    reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/)
        .replace('label', inline._label)
        .getRegex()
};
/**
 * GFM Inline Grammar
 */
inline.gfm = {
    ...inline.normal,
    escape: edit(inline.escape).replace('])', '~|])').getRegex(),
    _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
    url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
    _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
    del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
    text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
};
inline.gfm.url = edit(inline.gfm.url, 'i')
    .replace('email', inline.gfm._extended_email)
    .getRegex();
/**
 * GFM + Line Breaks Inline Grammar
 */
inline.breaks = {
    ...inline.gfm,
    br: edit(inline.br).replace('{2,}', '*').getRegex(),
    text: edit(inline.gfm.text)
        .replace('\\b_', '\\b_| {2,}\\n')
        .replace(/\{2,\}/g, '*')
        .getRegex()
};

/**
 * Block Lexer
 */
class _Lexer {
    tokens;
    options;
    state;
    tokenizer;
    inlineQueue;
    constructor(options) {
        // TokenList cannot be created in one go
        // @ts-expect-error
        this.tokens = [];
        this.tokens.links = Object.create(null);
        this.options = options || exports.defaults;
        this.options.tokenizer = this.options.tokenizer || new _Tokenizer();
        this.tokenizer = this.options.tokenizer;
        this.tokenizer.options = this.options;
        this.tokenizer.lexer = this;
        this.inlineQueue = [];
        this.state = {
            inLink: false,
            inRawBlock: false,
            top: true
        };
        const rules = {
            block: block.normal,
            inline: inline.normal
        };
        if (this.options.pedantic) {
            rules.block = block.pedantic;
            rules.inline = inline.pedantic;
        }
        else if (this.options.gfm) {
            rules.block = block.gfm;
            if (this.options.breaks) {
                rules.inline = inline.breaks;
            }
            else {
                rules.inline = inline.gfm;
            }
        }
        this.tokenizer.rules = rules;
    }
    /**
     * Expose Rules
     */
    static get rules() {
        return {
            block,
            inline
        };
    }
    /**
     * Static Lex Method
     */
    static lex(src, options) {
        const lexer = new _Lexer(options);
        return lexer.lex(src);
    }
    /**
     * Static Lex Inline Method
     */
    static lexInline(src, options) {
        const lexer = new _Lexer(options);
        return lexer.inlineTokens(src);
    }
    /**
     * Preprocessing
     */
    lex(src) {
        src = src
            .replace(/\r\n|\r/g, '\n');
        this.blockTokens(src, this.tokens);
        let next;
        while (next = this.inlineQueue.shift()) {
            this.inlineTokens(next.src, next.tokens);
        }
        return this.tokens;
    }
    blockTokens(src, tokens = []) {
        if (this.options.pedantic) {
            src = src.replace(/\t/g, '    ').replace(/^ +$/gm, '');
        }
        else {
            src = src.replace(/^( *)(\t+)/gm, (_, leading, tabs) => {
                return leading + '    '.repeat(tabs.length);
            });
        }
        let token;
        let lastToken;
        let cutSrc;
        let lastParagraphClipped;
        while (src) {
            if (this.options.extensions
                && this.options.extensions.block
                && this.options.extensions.block.some((extTokenizer) => {
                    if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
                        src = src.substring(token.raw.length);
                        tokens.push(token);
                        return true;
                    }
                    return false;
                })) {
                continue;
            }
            // newline
            if (token = this.tokenizer.space(src)) {
                src = src.substring(token.raw.length);
                if (token.raw.length === 1 && tokens.length > 0) {
                    // if there's a single \n as a spacer, it's terminating the last line,
                    // so move it there so that we don't get unnecessary paragraph tags
                    tokens[tokens.length - 1].raw += '\n';
                }
                else {
                    tokens.push(token);
                }
                continue;
            }
            // code
            if (token = this.tokenizer.code(src)) {
                src = src.substring(token.raw.length);
                lastToken = tokens[tokens.length - 1];
                // An indented code block cannot interrupt a paragraph.
                if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {
                    lastToken.raw += '\n' + token.raw;
                    lastToken.text += '\n' + token.text;
                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
                }
                else {
                    tokens.push(token);
                }
                continue;
            }
            // fences
            if (token = this.tokenizer.fences(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
            }
            // heading
            if (token = this.tokenizer.heading(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
            }
            // hr
            if (token = this.tokenizer.hr(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
            }
            // blockquote
            if (token = this.tokenizer.blockquote(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
            }
            // list
            if (token = this.tokenizer.list(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
            }
            // html
            if (token = this.tokenizer.html(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
            }
            // def
            if (token = this.tokenizer.def(src)) {
                src = src.substring(token.raw.length);
                lastToken = tokens[tokens.length - 1];
                if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {
                    lastToken.raw += '\n' + token.raw;
                    lastToken.text += '\n' + token.raw;
                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
                }
                else if (!this.tokens.links[token.tag]) {
                    this.tokens.links[token.tag] = {
                        href: token.href,
                        title: token.title
                    };
                }
                continue;
            }
            // table (gfm)
            if (token = this.tokenizer.table(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
            }
            // lheading
            if (token = this.tokenizer.lheading(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
            }
            // top-level paragraph
            // prevent paragraph consuming extensions by clipping 'src' to extension start
            cutSrc = src;
            if (this.options.extensions && this.options.extensions.startBlock) {
                let startIndex = Infinity;
                const tempSrc = src.slice(1);
                let tempStart;
                this.options.extensions.startBlock.forEach((getStartIndex) => {
                    tempStart = getStartIndex.call({ lexer: this }, tempSrc);
                    if (typeof tempStart === 'number' && tempStart >= 0) {
                        startIndex = Math.min(startIndex, tempStart);
                    }
                });
                if (startIndex < Infinity && startIndex >= 0) {
                    cutSrc = src.substring(0, startIndex + 1);
                }
            }
            if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {
                lastToken = tokens[tokens.length - 1];
                if (lastParagraphClipped && lastToken.type === 'paragraph') {
                    lastToken.raw += '\n' + token.raw;
                    lastToken.text += '\n' + token.text;
                    this.inlineQueue.pop();
                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
                }
                else {
                    tokens.push(token);
                }
                lastParagraphClipped = (cutSrc.length !== src.length);
                src = src.substring(token.raw.length);
                continue;
            }
            // text
            if (token = this.tokenizer.text(src)) {
                src = src.substring(token.raw.length);
                lastToken = tokens[tokens.length - 1];
                if (lastToken && lastToken.type === 'text') {
                    lastToken.raw += '\n' + token.raw;
                    lastToken.text += '\n' + token.text;
                    this.inlineQueue.pop();
                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
                }
                else {
                    tokens.push(token);
                }
                continue;
            }
            if (src) {
                const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);
                if (this.options.silent) {
                    console.error(errMsg);
                    break;
                }
                else {
                    throw new Error(errMsg);
                }
            }
        }
        this.state.top = true;
        return tokens;
    }
    inline(src, tokens = []) {
        this.inlineQueue.push({ src, tokens });
        return tokens;
    }
    /**
     * Lexing/Compiling
     */
    inlineTokens(src, tokens = []) {
        let token, lastToken, cutSrc;
        // String with links masked to avoid interference with em and strong
        let maskedSrc = src;
        let match;
        let keepPrevChar, prevChar;
        // Mask out reflinks
        if (this.tokens.links) {
            const links = Object.keys(this.tokens.links);
            if (links.length > 0) {
                while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
                    if (links.includes(match[0].slice(match[0].lastIndexOf('[') + 1, -1))) {
                        maskedSrc = maskedSrc.slice(0, match.index) + '[' + 'a'.repeat(match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
                    }
                }
            }
        }
        // Mask out other blocks
        while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
            maskedSrc = maskedSrc.slice(0, match.index) + '[' + 'a'.repeat(match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
        }
        // Mask out escaped characters
        while ((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null) {
            maskedSrc = maskedSrc.slice(0, match.index) + '++' + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
        }
        while (src) {
            if (!keepPrevChar) {
                prevChar = '';
            }
            keepPrevChar = false;
            // extensions
            if (this.options.extensions
                && this.options.extensions.inline
                && this.options.extensions.inline.some((extTokenizer) => {
                    if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
                        src = src.substring(token.raw.length);
                        tokens.push(token);
                        return true;
                    }
                    return false;
                })) {
                continue;
            }
            // escape
            if (token = this.tokenizer.escape(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
            }
            // tag
            if (token = this.tokenizer.tag(src)) {
                src = src.substring(token.raw.length);
                lastToken = tokens[tokens.length - 1];
                if (lastToken && token.type === 'text' && lastToken.type === 'text') {
                    lastToken.raw += token.raw;
                    lastToken.text += token.text;
                }
                else {
                    tokens.push(token);
                }
                continue;
            }
            // link
            if (token = this.tokenizer.link(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
            }
            // reflink, nolink
            if (token = this.tokenizer.reflink(src, this.tokens.links)) {
                src = src.substring(token.raw.length);
                lastToken = tokens[tokens.length - 1];
                if (lastToken && token.type === 'text' && lastToken.type === 'text') {
                    lastToken.raw += token.raw;
                    lastToken.text += token.text;
                }
                else {
                    tokens.push(token);
                }
                continue;
            }
            // em & strong
            if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
            }
            // code
            if (token = this.tokenizer.codespan(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
            }
            // br
            if (token = this.tokenizer.br(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
            }
            // del (gfm)
            if (token = this.tokenizer.del(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
            }
            // autolink
            if (token = this.tokenizer.autolink(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
            }
            // url (gfm)
            if (!this.state.inLink && (token = this.tokenizer.url(src))) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
            }
            // text
            // prevent inlineText consuming extensions by clipping 'src' to extension start
            cutSrc = src;
            if (this.options.extensions && this.options.extensions.startInline) {
                let startIndex = Infinity;
                const tempSrc = src.slice(1);
                let tempStart;
                this.options.extensions.startInline.forEach((getStartIndex) => {
                    tempStart = getStartIndex.call({ lexer: this }, tempSrc);
                    if (typeof tempStart === 'number' && tempStart >= 0) {
                        startIndex = Math.min(startIndex, tempStart);
                    }
                });
                if (startIndex < Infinity && startIndex >= 0) {
                    cutSrc = src.substring(0, startIndex + 1);
                }
            }
            if (token = this.tokenizer.inlineText(cutSrc)) {
                src = src.substring(token.raw.length);
                if (token.raw.slice(-1) !== '_') { // Track prevChar before string of ____ started
                    prevChar = token.raw.slice(-1);
                }
                keepPrevChar = true;
                lastToken = tokens[tokens.length - 1];
                if (lastToken && lastToken.type === 'text') {
                    lastToken.raw += token.raw;
                    lastToken.text += token.text;
                }
                else {
                    tokens.push(token);
                }
                continue;
            }
            if (src) {
                const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);
                if (this.options.silent) {
                    console.error(errMsg);
                    break;
                }
                else {
                    throw new Error(errMsg);
                }
            }
        }
        return tokens;
    }
}

/**
 * Renderer
 */
class _Renderer {
    options;
    constructor(options) {
        this.options = options || exports.defaults;
    }
    code(code, infostring, escaped) {
        const lang = (infostring || '').match(/^\S*/)?.[0];
        code = code.replace(/\n$/, '') + '\n';
        if (!lang) {
            return '<pre><code>'
                + (escaped ? code : escape(code, true))
                + '</code></pre>\n';
        }
        return '<pre><code class="language-'
            + escape(lang)
            + '">'
            + (escaped ? code : escape(code, true))
            + '</code></pre>\n';
    }
    blockquote(quote) {
        return `<blockquote>\n${quote}</blockquote>\n`;
    }
    html(html, block) {
        return html;
    }
    heading(text, level, raw) {
        // ignore IDs
        return `<h${level}>${text}</h${level}>\n`;
    }
    hr() {
        return '<hr>\n';
    }
    list(body, ordered, start) {
        const type = ordered ? 'ol' : 'ul';
        const startatt = (ordered && start !== 1) ? (' start="' + start + '"') : '';
        return '<' + type + startatt + '>\n' + body + '</' + type + '>\n';
    }
    listitem(text, task, checked) {
        return `<li>${text}</li>\n`;
    }
    checkbox(checked) {
        return '<input '
            + (checked ? 'checked="" ' : '')
            + 'disabled="" type="checkbox">';
    }
    paragraph(text) {
        return `<p>${text}</p>\n`;
    }
    table(header, body) {
        if (body)
            body = `<tbody>${body}</tbody>`;
        return '<table>\n'
            + '<thead>\n'
            + header
            + '</thead>\n'
            + body
            + '</table>\n';
    }
    tablerow(content) {
        return `<tr>\n${content}</tr>\n`;
    }
    tablecell(content, flags) {
        const type = flags.header ? 'th' : 'td';
        const tag = flags.align
            ? `<${type} align="${flags.align}">`
            : `<${type}>`;
        return tag + content + `</${type}>\n`;
    }
    /**
     * span level renderer
     */
    strong(text) {
        return `<strong>${text}</strong>`;
    }
    em(text) {
        return `<em>${text}</em>`;
    }
    codespan(text) {
        return `<code>${text}</code>`;
    }
    br() {
        return '<br>';
    }
    del(text) {
        return `<del>${text}</del>`;
    }
    link(href, title, text) {
        const cleanHref = cleanUrl(href);
        if (cleanHref === null) {
            return text;
        }
        href = cleanHref;
        let out = '<a href="' + href + '"';
        if (title) {
            out += ' title="' + title + '"';
        }
        out += '>' + text + '</a>';
        return out;
    }
    image(href, title, text) {
        const cleanHref = cleanUrl(href);
        if (cleanHref === null) {
            return text;
        }
        href = cleanHref;
        let out = `<img src="${href}" alt="${text}"`;
        if (title) {
            out += ` title="${title}"`;
        }
        out += '>';
        return out;
    }
    text(text) {
        return text;
    }
}

/**
 * TextRenderer
 * returns only the textual part of the token
 */
class _TextRenderer {
    // no need for block level renderers
    strong(text) {
        return text;
    }
    em(text) {
        return text;
    }
    codespan(text) {
        return text;
    }
    del(text) {
        return text;
    }
    html(text) {
        return text;
    }
    text(text) {
        return text;
    }
    link(href, title, text) {
        return '' + text;
    }
    image(href, title, text) {
        return '' + text;
    }
    br() {
        return '';
    }
}

/**
 * Parsing & Compiling
 */
class _Parser {
    options;
    renderer;
    textRenderer;
    constructor(options) {
        this.options = options || exports.defaults;
        this.options.renderer = this.options.renderer || new _Renderer();
        this.renderer = this.options.renderer;
        this.renderer.options = this.options;
        this.textRenderer = new _TextRenderer();
    }
    /**
     * Static Parse Method
     */
    static parse(tokens, options) {
        const parser = new _Parser(options);
        return parser.parse(tokens);
    }
    /**
     * Static Parse Inline Method
     */
    static parseInline(tokens, options) {
        const parser = new _Parser(options);
        return parser.parseInline(tokens);
    }
    /**
     * Parse Loop
     */
    parse(tokens, top = true) {
        let out = '';
        for (let i = 0; i < tokens.length; i++) {
            const token = tokens[i];
            // Run any renderer extensions
            if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
                const genericToken = token;
                const ret = this.options.extensions.renderers[genericToken.type].call({ parser: this }, genericToken);
                if (ret !== false || !['space', 'hr', 'heading', 'code', 'table', 'blockquote', 'list', 'html', 'paragraph', 'text'].includes(genericToken.type)) {
                    out += ret || '';
                    continue;
                }
            }
            switch (token.type) {
                case 'space': {
                    continue;
                }
                case 'hr': {
                    out += this.renderer.hr();
                    continue;
                }
                case 'heading': {
                    const headingToken = token;
                    out += this.renderer.heading(this.parseInline(headingToken.tokens), headingToken.depth, unescape(this.parseInline(headingToken.tokens, this.textRenderer)));
                    continue;
                }
                case 'code': {
                    const codeToken = token;
                    out += this.renderer.code(codeToken.text, codeToken.lang, !!codeToken.escaped);
                    continue;
                }
                case 'table': {
                    const tableToken = token;
                    let header = '';
                    // header
                    let cell = '';
                    for (let j = 0; j < tableToken.header.length; j++) {
                        cell += this.renderer.tablecell(this.parseInline(tableToken.header[j].tokens), { header: true, align: tableToken.align[j] });
                    }
                    header += this.renderer.tablerow(cell);
                    let body = '';
                    for (let j = 0; j < tableToken.rows.length; j++) {
                        const row = tableToken.rows[j];
                        cell = '';
                        for (let k = 0; k < row.length; k++) {
                            cell += this.renderer.tablecell(this.parseInline(row[k].tokens), { header: false, align: tableToken.align[k] });
                        }
                        body += this.renderer.tablerow(cell);
                    }
                    out += this.renderer.table(header, body);
                    continue;
                }
                case 'blockquote': {
                    const blockquoteToken = token;
                    const body = this.parse(blockquoteToken.tokens);
                    out += this.renderer.blockquote(body);
                    continue;
                }
                case 'list': {
                    const listToken = token;
                    const ordered = listToken.ordered;
                    const start = listToken.start;
                    const loose = listToken.loose;
                    let body = '';
                    for (let j = 0; j < listToken.items.length; j++) {
                        const item = listToken.items[j];
                        const checked = item.checked;
                        const task = item.task;
                        let itemBody = '';
                        if (item.task) {
                            const checkbox = this.renderer.checkbox(!!checked);
                            if (loose) {
                                if (item.tokens.length > 0 && item.tokens[0].type === 'paragraph') {
                                    item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;
                                    if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === 'text') {
                                        item.tokens[0].tokens[0].text = checkbox + ' ' + item.tokens[0].tokens[0].text;
                                    }
                                }
                                else {
                                    item.tokens.unshift({
                                        type: 'text',
                                        text: checkbox + ' '
                                    });
                                }
                            }
                            else {
                                itemBody += checkbox + ' ';
                            }
                        }
                        itemBody += this.parse(item.tokens, loose);
                        body += this.renderer.listitem(itemBody, task, !!checked);
                    }
                    out += this.renderer.list(body, ordered, start);
                    continue;
                }
                case 'html': {
                    const htmlToken = token;
                    out += this.renderer.html(htmlToken.text, htmlToken.block);
                    continue;
                }
                case 'paragraph': {
                    const paragraphToken = token;
                    out += this.renderer.paragraph(this.parseInline(paragraphToken.tokens));
                    continue;
                }
                case 'text': {
                    let textToken = token;
                    let body = textToken.tokens ? this.parseInline(textToken.tokens) : textToken.text;
                    while (i + 1 < tokens.length && tokens[i + 1].type === 'text') {
                        textToken = tokens[++i];
                        body += '\n' + (textToken.tokens ? this.parseInline(textToken.tokens) : textToken.text);
                    }
                    out += top ? this.renderer.paragraph(body) : body;
                    continue;
                }
                default: {
                    const errMsg = 'Token with "' + token.type + '" type was not found.';
                    if (this.options.silent) {
                        console.error(errMsg);
                        return '';
                    }
                    else {
                        throw new Error(errMsg);
                    }
                }
            }
        }
        return out;
    }
    /**
     * Parse Inline Tokens
     */
    parseInline(tokens, renderer) {
        renderer = renderer || this.renderer;
        let out = '';
        for (let i = 0; i < tokens.length; i++) {
            const token = tokens[i];
            // Run any renderer extensions
            if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
                const ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);
                if (ret !== false || !['escape', 'html', 'link', 'image', 'strong', 'em', 'codespan', 'br', 'del', 'text'].includes(token.type)) {
                    out += ret || '';
                    continue;
                }
            }
            switch (token.type) {
                case 'escape': {
                    const escapeToken = token;
                    out += renderer.text(escapeToken.text);
                    break;
                }
                case 'html': {
                    const tagToken = token;
                    out += renderer.html(tagToken.text);
                    break;
                }
                case 'link': {
                    const linkToken = token;
                    out += renderer.link(linkToken.href, linkToken.title, this.parseInline(linkToken.tokens, renderer));
                    break;
                }
                case 'image': {
                    const imageToken = token;
                    out += renderer.image(imageToken.href, imageToken.title, imageToken.text);
                    break;
                }
                case 'strong': {
                    const strongToken = token;
                    out += renderer.strong(this.parseInline(strongToken.tokens, renderer));
                    break;
                }
                case 'em': {
                    const emToken = token;
                    out += renderer.em(this.parseInline(emToken.tokens, renderer));
                    break;
                }
                case 'codespan': {
                    const codespanToken = token;
                    out += renderer.codespan(codespanToken.text);
                    break;
                }
                case 'br': {
                    out += renderer.br();
                    break;
                }
                case 'del': {
                    const delToken = token;
                    out += renderer.del(this.parseInline(delToken.tokens, renderer));
                    break;
                }
                case 'text': {
                    const textToken = token;
                    out += renderer.text(textToken.text);
                    break;
                }
                default: {
                    const errMsg = 'Token with "' + token.type + '" type was not found.';
                    if (this.options.silent) {
                        console.error(errMsg);
                        return '';
                    }
                    else {
                        throw new Error(errMsg);
                    }
                }
            }
        }
        return out;
    }
}

class _Hooks {
    options;
    constructor(options) {
        this.options = options || exports.defaults;
    }
    static passThroughHooks = new Set([
        'preprocess',
        'postprocess'
    ]);
    /**
     * Process markdown before marked
     */
    preprocess(markdown) {
        return markdown;
    }
    /**
     * Process HTML after marked is finished
     */
    postprocess(html) {
        return html;
    }
}

class Marked {
    defaults = _getDefaults();
    options = this.setOptions;
    parse = this.#parseMarkdown(_Lexer.lex, _Parser.parse);
    parseInline = this.#parseMarkdown(_Lexer.lexInline, _Parser.parseInline);
    Parser = _Parser;
    Renderer = _Renderer;
    TextRenderer = _TextRenderer;
    Lexer = _Lexer;
    Tokenizer = _Tokenizer;
    Hooks = _Hooks;
    constructor(...args) {
        this.use(...args);
    }
    /**
     * Run callback for every token
     */
    walkTokens(tokens, callback) {
        let values = [];
        for (const token of tokens) {
            values = values.concat(callback.call(this, token));
            switch (token.type) {
                case 'table': {
                    const tableToken = token;
                    for (const cell of tableToken.header) {
                        values = values.concat(this.walkTokens(cell.tokens, callback));
                    }
                    for (const row of tableToken.rows) {
                        for (const cell of row) {
                            values = values.concat(this.walkTokens(cell.tokens, callback));
                        }
                    }
                    break;
                }
                case 'list': {
                    const listToken = token;
                    values = values.concat(this.walkTokens(listToken.items, callback));
                    break;
                }
                default: {
                    const genericToken = token;
                    if (this.defaults.extensions?.childTokens?.[genericToken.type]) {
                        this.defaults.extensions.childTokens[genericToken.type].forEach((childTokens) => {
                            values = values.concat(this.walkTokens(genericToken[childTokens], callback));
                        });
                    }
                    else if (genericToken.tokens) {
                        values = values.concat(this.walkTokens(genericToken.tokens, callback));
                    }
                }
            }
        }
        return values;
    }
    use(...args) {
        const extensions = this.defaults.extensions || { renderers: {}, childTokens: {} };
        args.forEach((pack) => {
            // copy options to new object
            const opts = { ...pack };
            // set async to true if it was set to true before
            opts.async = this.defaults.async || opts.async || false;
            // ==-- Parse "addon" extensions --== //
            if (pack.extensions) {
                pack.extensions.forEach((ext) => {
                    if (!ext.name) {
                        throw new Error('extension name required');
                    }
                    if ('renderer' in ext) { // Renderer extensions
                        const prevRenderer = extensions.renderers[ext.name];
                        if (prevRenderer) {
                            // Replace extension with func to run new extension but fall back if false
                            extensions.renderers[ext.name] = function (...args) {
                                let ret = ext.renderer.apply(this, args);
                                if (ret === false) {
                                    ret = prevRenderer.apply(this, args);
                                }
                                return ret;
                            };
                        }
                        else {
                            extensions.renderers[ext.name] = ext.renderer;
                        }
                    }
                    if ('tokenizer' in ext) { // Tokenizer Extensions
                        if (!ext.level || (ext.level !== 'block' && ext.level !== 'inline')) {
                            throw new Error("extension level must be 'block' or 'inline'");
                        }
                        const extLevel = extensions[ext.level];
                        if (extLevel) {
                            extLevel.unshift(ext.tokenizer);
                        }
                        else {
                            extensions[ext.level] = [ext.tokenizer];
                        }
                        if (ext.start) { // Function to check for start of token
                            if (ext.level === 'block') {
                                if (extensions.startBlock) {
                                    extensions.startBlock.push(ext.start);
                                }
                                else {
                                    extensions.startBlock = [ext.start];
                                }
                            }
                            else if (ext.level === 'inline') {
                                if (extensions.startInline) {
                                    extensions.startInline.push(ext.start);
                                }
                                else {
                                    extensions.startInline = [ext.start];
                                }
                            }
                        }
                    }
                    if ('childTokens' in ext && ext.childTokens) { // Child tokens to be visited by walkTokens
                        extensions.childTokens[ext.name] = ext.childTokens;
                    }
                });
                opts.extensions = extensions;
            }
            // ==-- Parse "overwrite" extensions --== //
            if (pack.renderer) {
                const renderer = this.defaults.renderer || new _Renderer(this.defaults);
                for (const prop in pack.renderer) {
                    const rendererFunc = pack.renderer[prop];
                    const rendererKey = prop;
                    const prevRenderer = renderer[rendererKey];
                    // Replace renderer with func to run extension, but fall back if false
                    renderer[rendererKey] = (...args) => {
                        let ret = rendererFunc.apply(renderer, args);
                        if (ret === false) {
                            ret = prevRenderer.apply(renderer, args);
                        }
                        return ret || '';
                    };
                }
                opts.renderer = renderer;
            }
            if (pack.tokenizer) {
                const tokenizer = this.defaults.tokenizer || new _Tokenizer(this.defaults);
                for (const prop in pack.tokenizer) {
                    const tokenizerFunc = pack.tokenizer[prop];
                    const tokenizerKey = prop;
                    const prevTokenizer = tokenizer[tokenizerKey];
                    // Replace tokenizer with func to run extension, but fall back if false
                    tokenizer[tokenizerKey] = (...args) => {
                        let ret = tokenizerFunc.apply(tokenizer, args);
                        if (ret === false) {
                            ret = prevTokenizer.apply(tokenizer, args);
                        }
                        return ret;
                    };
                }
                opts.tokenizer = tokenizer;
            }
            // ==-- Parse Hooks extensions --== //
            if (pack.hooks) {
                const hooks = this.defaults.hooks || new _Hooks();
                for (const prop in pack.hooks) {
                    const hooksFunc = pack.hooks[prop];
                    const hooksKey = prop;
                    const prevHook = hooks[hooksKey];
                    if (_Hooks.passThroughHooks.has(prop)) {
                        hooks[hooksKey] = (arg) => {
                            if (this.defaults.async) {
                                return Promise.resolve(hooksFunc.call(hooks, arg)).then(ret => {
                                    return prevHook.call(hooks, ret);
                                });
                            }
                            const ret = hooksFunc.call(hooks, arg);
                            return prevHook.call(hooks, ret);
                        };
                    }
                    else {
                        hooks[hooksKey] = (...args) => {
                            let ret = hooksFunc.apply(hooks, args);
                            if (ret === false) {
                                ret = prevHook.apply(hooks, args);
                            }
                            return ret;
                        };
                    }
                }
                opts.hooks = hooks;
            }
            // ==-- Parse WalkTokens extensions --== //
            if (pack.walkTokens) {
                const walkTokens = this.defaults.walkTokens;
                const packWalktokens = pack.walkTokens;
                opts.walkTokens = function (token) {
                    let values = [];
                    values.push(packWalktokens.call(this, token));
                    if (walkTokens) {
                        values = values.concat(walkTokens.call(this, token));
                    }
                    return values;
                };
            }
            this.defaults = { ...this.defaults, ...opts };
        });
        return this;
    }
    setOptions(opt) {
        this.defaults = { ...this.defaults, ...opt };
        return this;
    }
    lexer(src, options) {
        return _Lexer.lex(src, options ?? this.defaults);
    }
    parser(tokens, options) {
        return _Parser.parse(tokens, options ?? this.defaults);
    }
    #parseMarkdown(lexer, parser) {
        return (src, options) => {
            const origOpt = { ...options };
            const opt = { ...this.defaults, ...origOpt };
            // Show warning if an extension set async to true but the parse was called with async: false
            if (this.defaults.async === true && origOpt.async === false) {
                if (!opt.silent) {
                    console.warn('marked(): The async option was set to true by an extension. The async: false option sent to parse will be ignored.');
                }
                opt.async = true;
            }
            const throwError = this.#onError(!!opt.silent, !!opt.async);
            // throw error in case of non string input
            if (typeof src === 'undefined' || src === null) {
                return throwError(new Error('marked(): input parameter is undefined or null'));
            }
            if (typeof src !== 'string') {
                return throwError(new Error('marked(): input parameter is of type '
                    + Object.prototype.toString.call(src) + ', string expected'));
            }
            if (opt.hooks) {
                opt.hooks.options = opt;
            }
            if (opt.async) {
                return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src)
                    .then(src => lexer(src, opt))
                    .then(tokens => opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(() => tokens) : tokens)
                    .then(tokens => parser(tokens, opt))
                    .then(html => opt.hooks ? opt.hooks.postprocess(html) : html)
                    .catch(throwError);
            }
            try {
                if (opt.hooks) {
                    src = opt.hooks.preprocess(src);
                }
                const tokens = lexer(src, opt);
                if (opt.walkTokens) {
                    this.walkTokens(tokens, opt.walkTokens);
                }
                let html = parser(tokens, opt);
                if (opt.hooks) {
                    html = opt.hooks.postprocess(html);
                }
                return html;
            }
            catch (e) {
                return throwError(e);
            }
        };
    }
    #onError(silent, async) {
        return (e) => {
            e.message += '\nPlease report this to https://github.com/markedjs/marked.';
            if (silent) {
                const msg = '<p>An error occurred:</p><pre>'
                    + escape(e.message + '', true)
                    + '</pre>';
                if (async) {
                    return Promise.resolve(msg);
                }
                return msg;
            }
            if (async) {
                return Promise.reject(e);
            }
            throw e;
        };
    }
}

const markedInstance = new Marked();
function marked(src, opt) {
    return markedInstance.parse(src, opt);
}
/**
 * Sets the default options.
 *
 * @param options Hash of options
 */
marked.options =
    marked.setOptions = function (options) {
        markedInstance.setOptions(options);
        marked.defaults = markedInstance.defaults;
        changeDefaults(marked.defaults);
        return marked;
    };
/**
 * Gets the original marked default options.
 */
marked.getDefaults = _getDefaults;
marked.defaults = exports.defaults;
/**
 * Use Extension
 */
marked.use = function (...args) {
    markedInstance.use(...args);
    marked.defaults = markedInstance.defaults;
    changeDefaults(marked.defaults);
    return marked;
};
/**
 * Run callback for every token
 */
marked.walkTokens = function (tokens, callback) {
    return markedInstance.walkTokens(tokens, callback);
};
/**
 * Compiles markdown to HTML without enclosing `p` tag.
 *
 * @param src String of markdown source to be compiled
 * @param options Hash of options
 * @return String of compiled HTML
 */
marked.parseInline = markedInstance.parseInline;
/**
 * Expose
 */
marked.Parser = _Parser;
marked.parser = _Parser.parse;
marked.Renderer = _Renderer;
marked.TextRenderer = _TextRenderer;
marked.Lexer = _Lexer;
marked.lexer = _Lexer.lex;
marked.Tokenizer = _Tokenizer;
marked.Hooks = _Hooks;
marked.parse = marked;
const options = marked.options;
const setOptions = marked.setOptions;
const use = marked.use;
const walkTokens = marked.walkTokens;
const parseInline = marked.parseInline;
const parse = marked;
const parser = _Parser.parse;
const lexer = _Lexer.lex;

exports.Hooks = _Hooks;
exports.Lexer = _Lexer;
exports.Marked = Marked;
exports.Parser = _Parser;
exports.Renderer = _Renderer;
exports.TextRenderer = _TextRenderer;
exports.Tokenizer = _Tokenizer;
exports.getDefaults = _getDefaults;
exports.lexer = lexer;
exports.marked = marked;
exports.options = options;
exports.parse = parse;
exports.parseInline = parseInline;
exports.parser = parser;
exports.setOptions = setOptions;
exports.use = use;
exports.walkTokens = walkTokens;
//# sourceMappingURL=marked.cjs.map


/***/ }),

/***/ "./src/content/index.ts":
/*!******************************!*\
  !*** ./src/content/index.ts ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/// <reference types="chrome" />
const types_1 = __webpack_require__(/*! ../shared/types */ "./src/shared/types.ts");
const utils_1 = __webpack_require__(/*! ../shared/utils */ "./src/shared/utils.ts");
const marked_1 = __webpack_require__(/*! marked */ "./node_modules/marked/lib/marked.cjs");
// Initialize as null
window.multimodalOptionsElement = null;
// Initialize marked options for security
marked_1.marked.setOptions({
    breaks: true, // Convert \n to <br>
    gfm: true, // GitHub Flavored Markdown
});
// Store any active tooltip element
let activeTooltip = null;
let selectionButton = null;
let activeConversationHistory = [];
let activeText = "";
let userSettings = null;
// State for tracking multimodal selections
let pendingMultimodalSelection = {
    text: null,
    textContext: null,
    mediaType: null,
    mediaUrl: null,
    mediaElement: null,
    selection: null,
};
// Update the settings to match the correct type
let settings = {
    apiKey: "",
    perplexityApiKey: "",
    theme: "auto",
    maxTokens: 1000,
    cacheEnabled: true,
    cacheExpiry: 24,
    webSearchEnabled: true,
    keyboardShortcut: {
        key: "E",
        ctrlKey: false,
        shiftKey: true,
        altKey: false,
        metaKey: true, // Command key on Mac, Windows key on Windows
    },
    multimodalEnabled: true, // Enable multimodal content by default
    historyRetention: 7, // Default to 7 days retention
};
// Keep track of connection status
let isConnected = false;
let reconnectAttempts = 0;
const MAX_RECONNECT_ATTEMPTS = 5;
const RECONNECT_DELAY = 1000; // 1 second
// Tooltip state management
let dragState = null;
let hasBeenMoved = false;
// Function to establish connection with background script
function connectToBackground() {
    try {
        const port = chrome.runtime.connect({ name: "content-script" });
        port.onDisconnect.addListener(() => {
            console.log("Disconnected from background script");
            isConnected = false;
            if (chrome.runtime.lastError) {
                console.error("Connection error:", chrome.runtime.lastError);
            }
            // Try to reconnect if we haven't exceeded max attempts
            if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
                reconnectAttempts++;
                console.log(`Attempting to reconnect (${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})...`);
                setTimeout(connectToBackground, RECONNECT_DELAY);
            }
            else {
                console.error("Max reconnection attempts reached");
                showError(activeTooltip || createTooltip("Error"), "Lost connection to extension. Please refresh the page.");
            }
        });
        port.onMessage.addListener((message) => {
            console.log("Received message from background:", message);
        });
        isConnected = true;
        reconnectAttempts = 0;
        console.log("Connected to background script");
    }
    catch (error) {
        console.error("Error connecting to background:", error);
        isConnected = false;
    }
}
// Initialize function
function init() {
    // Connect to background script
    connectToBackground();
    // Listen for text selection events
    document.addEventListener("mouseup", handleTextSelection);
    // Load settings
    loadSettings();
    // Add keyboard shortcut listener
    setupKeyboardShortcuts();
    console.log("AI Dictionary+ content script initialized");
    // Listen for messages from the background script
    chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
        var _a, _b;
        console.log("Content script received message:", message, sender);
        const { type, payload } = message;
        // Handle potential disconnections
        if (chrome.runtime.lastError) {
            console.error("Runtime error:", chrome.runtime.lastError);
            if ((_a = chrome.runtime.lastError.message) === null || _a === void 0 ? void 0 : _a.includes("Extension context invalidated")) {
                isConnected = false;
                connectToBackground();
            }
            return;
        }
        switch (type) {
            case types_1.MessageType.EXPLAIN_TEXT:
                if (payload.text) {
                    console.log("Handling explain request for:", payload.text);
                    handleExplainRequest(payload.text);
                    sendResponse({ success: true });
                }
                break;
            case types_1.MessageType.EXPLANATION_RESULT:
                showExplanation(payload);
                sendResponse({ success: true });
                break;
            case types_1.MessageType.SETTINGS_UPDATED:
                // Refresh any active UI with new settings
                loadSettings();
                if (activeTooltip) {
                    applyTheme(activeTooltip);
                }
                sendResponse({ success: true });
                break;
            case types_1.MessageType.WEB_SEARCH_RESULT:
                showWebSearchResult(payload);
                sendResponse({ success: true });
                break;
            case types_1.MessageType.EXPLAIN_MEDIA:
                console.log("Content script handling EXPLAIN_MEDIA request:", payload);
                if (payload.mediaType && payload.mediaUrl) {
                    handleMediaExplainRequest(payload.mediaType, payload.mediaUrl, payload.pageUrl);
                    sendResponse({ success: true });
                }
                else {
                    console.error("Missing required media properties");
                    sendResponse({
                        success: false,
                        error: "Missing required media properties",
                    });
                }
                break;
            case types_1.MessageType.MEDIA_EXPLANATION_RESULT:
                showMediaExplanation(payload);
                sendResponse({ success: true });
                break;
            case "CONTEXT_MENU_CLICKED":
                const { mediaType, mediaUrl } = payload;
                // Store the media information for potential multimodal use
                pendingMultimodalSelection.mediaType = mediaType;
                pendingMultimodalSelection.mediaUrl = mediaUrl;
                pendingMultimodalSelection.mediaElement = findMediaElement(mediaType, mediaUrl);
                // Highlight the selected elements
                if (pendingMultimodalSelection.text &&
                    pendingMultimodalSelection.mediaElement) {
                    highlightSelectedElements(pendingMultimodalSelection.text, pendingMultimodalSelection.mediaElement);
                }
                // If there's already text selected, show options instead of immediately handling
                if (pendingMultimodalSelection.text &&
                    ((_b = window.getSelection()) === null || _b === void 0 ? void 0 : _b.toString().trim()) ===
                        pendingMultimodalSelection.text) {
                    console.log("Text and media selected, showing multimodal options");
                    // Create a synthetic mouse event at the position of the media element
                    let posX = 0;
                    let posY = 0;
                    if (pendingMultimodalSelection.mediaElement) {
                        const rect = pendingMultimodalSelection.mediaElement.getBoundingClientRect();
                        posX = window.scrollX + rect.left;
                        posY = window.scrollY + rect.bottom;
                    }
                    const syntheticEvent = {
                        pageX: posX,
                        pageY: posY,
                    };
                    // Show options for combined or separate explanations
                    showMultimodalOptions(syntheticEvent);
                }
                else {
                    // No text selection active, just handle media explanation
                    handleMediaExplainRequest(mediaType, mediaUrl, window.location.href);
                }
                sendResponse({ success: true });
                return true;
            default:
                return false;
        }
        // Return true to indicate async response
        return true;
    });
}
// Load user settings
function loadSettings() {
    return __awaiter(this, void 0, void 0, function* () {
        userSettings = yield (0, utils_1.getSettings)();
    });
}
/**
 * Setup keyboard shortcuts for the extension
 */
function setupKeyboardShortcuts() {
    document.addEventListener("keydown", (event) => {
        // Check if we have settings loaded
        if (!userSettings)
            return;
        // Check for text shortcut (Alt+D by default)
        if (event.altKey && event.key === "d") {
            handleKeyboardShortcutPress();
        }
    });
}
/**
 * Handle keyboard shortcut press
 */
function handleKeyboardShortcutPress() {
    const selection = window.getSelection();
    if (!selection || selection.isCollapsed) {
        // No text selected, show notification
        showToast("Please select some text first before using the keyboard shortcut.");
        return;
    }
    const selectedText = selection.toString().trim();
    // Check if text meets requirements
    if (selectedText.length < 3 || selectedText.length > 2000) {
        showToast(selectedText.length < 3
            ? "Please select at least 3 characters of text."
            : "Selected text is too long (max 2000 characters).");
        return;
    }
    // Save context
    let contextText = "";
    try {
        if (selection.rangeCount > 0) {
            const range = selection.getRangeAt(0);
            const container = range.commonAncestorContainer;
            // Get nearest block element
            let contextNode = container;
            if (container.nodeType === Node.TEXT_NODE && container.parentElement) {
                contextNode = container.parentElement;
            }
            if (contextNode && contextNode.textContent) {
                contextText = contextNode.textContent.trim();
            }
        }
    }
    catch (error) {
        console.error("Error getting context for selection:", error);
    }
    // Check if we have a pending multimodal selection
    if (pendingMultimodalSelection.mediaType &&
        pendingMultimodalSelection.mediaUrl &&
        pendingMultimodalSelection.mediaElement) {
        // Update text part of multimodal selection
        pendingMultimodalSelection.text = selectedText;
        pendingMultimodalSelection.textContext = contextText;
        pendingMultimodalSelection.selection = selection;
        // Highlight selections to provide visual feedback
        if (pendingMultimodalSelection.mediaElement) {
            highlightSelectedElements(selectedText, pendingMultimodalSelection.mediaElement);
        }
        // Handle the multimodal request
        handleMultimodalRequest();
    }
    else {
        // Regular text shortcut behavior
        handleExplainRequest(selectedText);
    }
}
/**
 * Show a toast notification
 */
function showToast(message) {
    const toast = document.createElement("div");
    toast.className = "ai-dictionary-toast";
    toast.textContent = message;
    toast.style.position = "fixed";
    toast.style.bottom = "20px";
    toast.style.left = "50%";
    toast.style.transform = "translateX(-50%)";
    toast.style.backgroundColor = "rgba(0, 0, 0, 0.8)";
    toast.style.color = "white";
    toast.style.padding = "10px 20px";
    toast.style.borderRadius = "4px";
    toast.style.zIndex = "10000";
    toast.style.fontSize = "14px";
    toast.style.boxShadow = "0 2px 10px rgba(0, 0, 0, 0.2)";
    document.body.appendChild(toast);
    // Remove after 3 seconds
    setTimeout(() => {
        if (toast.parentNode) {
            toast.parentNode.removeChild(toast);
        }
    }, 3000);
}
// Handle keyboard shortcuts
function handleKeyboardShortcut(event) {
    var _a;
    // Only proceed if we have settings
    if (!userSettings || !userSettings.keyboardShortcut)
        return;
    const { key, ctrlKey, shiftKey, altKey, metaKey } = userSettings.keyboardShortcut;
    // Check if the pressed key combination matches the configured shortcut
    if (event.key.toLowerCase() === key.toLowerCase() &&
        event.ctrlKey === ctrlKey &&
        event.shiftKey === shiftKey &&
        event.altKey === altKey &&
        event.metaKey === metaKey) {
        // Get the current text selection
        const selectedText = ((_a = window.getSelection()) === null || _a === void 0 ? void 0 : _a.toString().trim()) || "";
        // Only proceed if there's a valid selection
        if ((0, utils_1.isValidText)(selectedText)) {
            event.preventDefault(); // Prevent any default action for this key combination
            console.log("Shortcut triggered for text:", selectedText);
            // Update the pending multimodal selection state with current text
            pendingMultimodalSelection.text = selectedText;
            pendingMultimodalSelection.textContext =
                getContextText(selectedText) || null;
            // Check if we have a pending media selection
            if (pendingMultimodalSelection.mediaType &&
                pendingMultimodalSelection.mediaUrl) {
                console.log("Multimodal content detected, handling combined explanation");
                handleMultimodalRequest();
            }
            else {
                // Also check if there's a media element that's currently in focus or selected
                const selectedMedia = getSelectedMediaElement();
                if (selectedMedia) {
                    console.log("Found selected media element:", selectedMedia);
                    // Update the pending multimodal selection
                    pendingMultimodalSelection.mediaType = selectedMedia.mediaType;
                    pendingMultimodalSelection.mediaUrl = selectedMedia.mediaUrl;
                    pendingMultimodalSelection.mediaElement = selectedMedia.element;
                    // Show a notification about available multimodal explanation
                    showMultimodalOptions(event);
                }
                else {
                    // No media detected, proceed with regular text explanation
                    handleExplainRequest(selectedText);
                }
            }
        }
    }
}
// Function to find selected or focused media elements
function getSelectedMediaElement() {
    var _a, _b, _c, _d;
    // Check if there's a media element currently in focus
    if (document.activeElement) {
        const activeElement = document.activeElement;
        if (activeElement.tagName.toLowerCase() === "img") {
            return {
                mediaType: types_1.MediaType.IMAGE,
                mediaUrl: activeElement.src,
                element: activeElement,
            };
        }
        else if (activeElement.tagName.toLowerCase() === "video") {
            const videoElement = activeElement;
            const src = videoElement.src ||
                ((_a = videoElement.querySelector("source")) === null || _a === void 0 ? void 0 : _a.src);
            if (src) {
                return {
                    mediaType: types_1.MediaType.VIDEO,
                    mediaUrl: src,
                    element: videoElement,
                };
            }
        }
        else if (activeElement.tagName.toLowerCase() === "audio") {
            const audioElement = activeElement;
            const src = audioElement.src ||
                ((_b = audioElement.querySelector("source")) === null || _b === void 0 ? void 0 : _b.src);
            if (src) {
                return {
                    mediaType: types_1.MediaType.AUDIO,
                    mediaUrl: src,
                    element: audioElement,
                };
            }
        }
    }
    // Check for media elements near the current selection
    const selection = window.getSelection();
    if (selection && selection.rangeCount > 0) {
        const range = selection.getRangeAt(0);
        const selectionRect = range.getBoundingClientRect();
        // Find all media elements on the page
        const mediaElements = [
            ...document.querySelectorAll("img, video, audio"),
        ];
        // Find the closest media element to the selection
        const closestElement = mediaElements.reduce((closest, element) => {
            const rect = element.getBoundingClientRect();
            // Check if media element is near the selection (within 100px)
            const distance = Math.min(Math.abs(rect.left - selectionRect.right), Math.abs(rect.right - selectionRect.left), Math.abs(rect.top - selectionRect.bottom), Math.abs(rect.bottom - selectionRect.top));
            if (distance < 100 && (!closest || distance < closest.distance)) {
                return { element, distance };
            }
            return closest;
        }, null);
        if (closestElement) {
            const element = closestElement.element;
            if (element.tagName.toLowerCase() === "img") {
                return {
                    mediaType: types_1.MediaType.IMAGE,
                    mediaUrl: element.src,
                    element,
                };
            }
            else if (element.tagName.toLowerCase() === "video") {
                const videoElement = element;
                const src = videoElement.src ||
                    ((_c = videoElement.querySelector("source")) === null || _c === void 0 ? void 0 : _c.src);
                if (src) {
                    return {
                        mediaType: types_1.MediaType.VIDEO,
                        mediaUrl: src,
                        element: videoElement,
                    };
                }
            }
            else if (element.tagName.toLowerCase() === "audio") {
                const audioElement = element;
                const src = audioElement.src ||
                    ((_d = audioElement.querySelector("source")) === null || _d === void 0 ? void 0 : _d.src);
                if (src) {
                    return {
                        mediaType: types_1.MediaType.AUDIO,
                        mediaUrl: src,
                        element: audioElement,
                    };
                }
            }
        }
    }
    return null;
}
// Show options for multimodal explanation
function showMultimodalOptions(event) {
    if (!pendingMultimodalSelection.text ||
        !pendingMultimodalSelection.mediaType ||
        !pendingMultimodalSelection.mediaUrl) {
        return;
    }
    // Create options container
    const optionsContainer = document.createElement("div");
    optionsContainer.className = "ai-dictionary-multimodal-options";
    optionsContainer.style.position = "fixed";
    optionsContainer.style.zIndex = "10001";
    optionsContainer.style.backgroundColor = "white";
    optionsContainer.style.border = "1px solid #ccc";
    optionsContainer.style.borderRadius = "6px";
    optionsContainer.style.boxShadow = "0 2px 10px rgba(0,0,0,0.2)";
    optionsContainer.style.padding = "10px";
    // Position near the event or text selection
    const selection = window.getSelection();
    if (selection && selection.rangeCount > 0) {
        const range = selection.getRangeAt(0);
        const rect = range.getBoundingClientRect();
        optionsContainer.style.top = `${window.scrollY + rect.bottom + 10}px`;
        optionsContainer.style.left = `${window.scrollX + rect.left}px`;
    }
    else if (event instanceof MouseEvent) {
        optionsContainer.style.top = `${event.pageY + 10}px`;
        optionsContainer.style.left = `${event.pageX + 10}px`;
    }
    else {
        // Default position
        optionsContainer.style.top = "100px";
        optionsContainer.style.left = "100px";
    }
    // Add title
    const title = document.createElement("div");
    title.textContent = "AI Dictionary+ Detected Text and Media";
    title.style.marginBottom = "10px";
    title.style.fontWeight = "bold";
    optionsContainer.appendChild(title);
    // Add buttons container
    const buttonsContainer = document.createElement("div");
    buttonsContainer.style.display = "flex";
    buttonsContainer.style.gap = "8px";
    // Button for text-only explanation
    const textButton = document.createElement("button");
    textButton.textContent = "Explain Text Only";
    textButton.className = "ai-dictionary-option-button";
    textButton.addEventListener("click", () => {
        removeMultimodalOptions();
        handleExplainRequest(pendingMultimodalSelection.text);
    });
    buttonsContainer.appendChild(textButton);
    // Button for media-only explanation
    const mediaButton = document.createElement("button");
    mediaButton.textContent = `Explain ${pendingMultimodalSelection.mediaType} Only`;
    mediaButton.className = "ai-dictionary-option-button";
    mediaButton.addEventListener("click", () => {
        removeMultimodalOptions();
        handleMediaExplainRequest(pendingMultimodalSelection.mediaType, pendingMultimodalSelection.mediaUrl, window.location.href);
    });
    buttonsContainer.appendChild(mediaButton);
    // Button for combined explanation
    const combinedButton = document.createElement("button");
    combinedButton.textContent = "Explain Both Together";
    combinedButton.className = "ai-dictionary-option-button";
    combinedButton.style.backgroundColor = "#4285f4";
    combinedButton.style.color = "white";
    combinedButton.addEventListener("click", () => {
        removeMultimodalOptions();
        handleMultimodalRequest();
    });
    buttonsContainer.appendChild(combinedButton);
    optionsContainer.appendChild(buttonsContainer);
    document.body.appendChild(optionsContainer);
    // Store reference to remove later
    window.multimodalOptionsElement = optionsContainer;
    // Auto-remove after a few seconds
    setTimeout(removeMultimodalOptions, 8000);
}
// Remove multimodal options dialog
function removeMultimodalOptions() {
    if (window.multimodalOptionsElement &&
        document.body.contains(window.multimodalOptionsElement)) {
        document.body.removeChild(window.multimodalOptionsElement);
        window.multimodalOptionsElement = null;
    }
}
/**
 * Highlights selected elements (text + media) to provide visual feedback
 */
function highlightSelectedElements(selectedText, mediaElement) {
    // Remove any previous highlights
    const existingHighlights = document.querySelectorAll(".ai-dictionary-highlight-indicator");
    existingHighlights.forEach((el) => el.remove());
    // Highlight the media element
    const originalOutline = mediaElement.style.outline;
    const originalBoxShadow = mediaElement.style.boxShadow;
    // Apply highlight effect
    mediaElement.style.outline = "3px solid rgba(66, 133, 244, 0.8)";
    mediaElement.style.boxShadow = "0 0 10px rgba(66, 133, 244, 0.6)";
    // Create an indicator label
    const indicator = document.createElement("div");
    indicator.className = "ai-dictionary-highlight-indicator";
    indicator.style.position = "absolute";
    indicator.style.backgroundColor = "rgba(66, 133, 244, 0.95)";
    indicator.style.color = "white";
    indicator.style.padding = "4px 8px";
    indicator.style.borderRadius = "4px";
    indicator.style.fontSize = "12px";
    indicator.style.fontWeight = "bold";
    indicator.style.boxShadow = "0 2px 4px rgba(0,0,0,0.2)";
    indicator.style.zIndex = "9999";
    indicator.style.pointerEvents = "none"; // Don't interfere with user interaction
    indicator.style.transition = "opacity 0.2s ease-in-out";
    indicator.textContent = "Text + Media selected";
    // Position the indicator near the element
    const rect = mediaElement.getBoundingClientRect();
    indicator.style.left = `${window.scrollX + rect.left}px`;
    indicator.style.top = `${window.scrollY + rect.top - 30}px`;
    // Add to document
    document.body.appendChild(indicator);
    // Remove the highlight after 1.5 seconds
    setTimeout(() => {
        mediaElement.style.outline = originalOutline;
        mediaElement.style.boxShadow = originalBoxShadow;
        // Fade out and remove the indicator
        indicator.style.opacity = "0";
        setTimeout(() => {
            if (indicator.parentNode) {
                indicator.parentNode.removeChild(indicator);
            }
        }, 200);
    }, 1500);
}
// Function to handle text selection
const handleTextSelection = (0, utils_1.debounce)((event) => __awaiter(void 0, void 0, void 0, function* () {
    // Remove any existing selection button
    removeSelectionButton();
    const selection = window.getSelection();
    if (!selection || selection.toString().trim() === "") {
        return;
    }
    const text = selection.toString().trim();
    if (!(0, utils_1.isValidText)(text)) {
        return;
    }
    // Store the selected text for potential multimodal use
    pendingMultimodalSelection.text = text;
    pendingMultimodalSelection.textContext = getContextText(text) || null;
    // Create a button near the selection
    createSelectionButton(event, text);
    // If we also have media selected, highlight it
    if (pendingMultimodalSelection.mediaElement) {
        highlightSelectedElements(text, pendingMultimodalSelection.mediaElement);
    }
}), 300);
// Function to explain selected text
function explainText(text) {
    // Create loading tooltip
    const tooltip = createTooltip(text);
    showLoadingState(tooltip);
    // Get context text
    const contextText = getContextText(text);
    // Send request to background script
    console.log("Sending request to background script");
    chrome.runtime.sendMessage({
        type: types_1.MessageType.EXPLAIN_TEXT,
        payload: {
            text,
            contextText,
            pageUrl: window.location.href, // Add the current page URL
        },
    }, (response) => {
        console.log("Received response from background script:", response);
        if (chrome.runtime.lastError) {
            console.error("Error sending message:", chrome.runtime.lastError);
            showError(tooltip, "Error communicating with the extension.");
            return;
        }
        if (response.error) {
            console.error("Error in response:", response.error);
            showError(tooltip, response.error);
            return;
        }
        console.log("Showing explanation in tooltip");
        // Update UI with explanation
        showExplanation(response, tooltip);
    });
}
// Create a button near the selected text
function createSelectionButton(event, text) {
    console.log("Creating selection button for:", text);
    // Create button container
    const buttonContainer = document.createElement("div");
    buttonContainer.className = "ai-dictionary-selection-buttons";
    buttonContainer.style.position = "absolute";
    buttonContainer.style.left = `${event.pageX + 10}px`;
    buttonContainer.style.top = `${event.pageY + 10}px`;
    buttonContainer.style.zIndex = "10000"; // Ensure it's on top
    buttonContainer.style.display = "flex";
    buttonContainer.style.gap = "5px";
    // Create explain button
    const explainButton = document.createElement("button");
    explainButton.className = "ai-dictionary-button";
    explainButton.textContent = "Explain";
    explainButton.addEventListener("click", (e) => {
        console.log("Selection button clicked for text:", text);
        e.stopPropagation(); // Prevent document click from removing tooltip immediately
        removeSelectionButton();
        handleExplainRequest(text);
        // Clear multimodal state
        resetMultimodalSelection();
    });
    buttonContainer.appendChild(explainButton);
    // If there's a pending media selection, add a "Combine with Media" button
    if (pendingMultimodalSelection.mediaType &&
        pendingMultimodalSelection.mediaUrl) {
        const combineButton = document.createElement("button");
        combineButton.className =
            "ai-dictionary-button ai-dictionary-combine-button";
        combineButton.textContent = "Explain with Media";
        combineButton.style.backgroundColor = "#4285f4";
        combineButton.style.color = "white";
        combineButton.addEventListener("click", (e) => {
            console.log("Combine button clicked for text and media:", text, pendingMultimodalSelection.mediaUrl);
            e.stopPropagation();
            removeSelectionButton();
            handleMultimodalRequest();
        });
        buttonContainer.appendChild(combineButton);
    }
    document.body.appendChild(buttonContainer);
    console.log("Selection buttons added to document.body");
    selectionButton = buttonContainer;
    // Automatically remove the button after 3 seconds
    setTimeout(() => {
        removeSelectionButton();
    }, 5000);
}
// Remove the selection button
function removeSelectionButton() {
    if (selectionButton && document.body.contains(selectionButton)) {
        document.body.removeChild(selectionButton);
        selectionButton = null;
    }
}
// Handle an explain request
function handleExplainRequest(text) {
    return __awaiter(this, void 0, void 0, function* () {
        console.log("Handling explain request for text:", text);
        // Store the active text
        activeText = text;
        // Create loading tooltip
        const tooltip = createTooltip(text);
        // Make the tooltip very visible
        tooltip.style.border = "2px solid #4285f4";
        tooltip.style.boxShadow = "0 4px 20px rgba(0, 0, 0, 0.3)";
        showLoadingState(tooltip);
        try {
            // Send request to background script using safe message sending
            console.log("Sending explain request to background script");
            const response = yield sendBackgroundMessage({
                type: types_1.MessageType.EXPLAIN_TEXT,
                payload: {
                    text,
                    contextText: getContextText(text),
                },
            });
            console.log("Received response from background script:", response);
            if (response.error) {
                console.error("Error in response:", response.error);
                showError(tooltip, response.error);
                return;
            }
            console.log("Showing explanation in tooltip");
            // Update UI with explanation
            showExplanation(response, tooltip);
        }
        catch (error) {
            console.error("Error in handleExplainRequest:", error);
            showError(tooltip, error instanceof Error
                ? error.message
                : "An error occurred while getting the explanation.");
        }
    });
}
// Get enhanced surrounding context for the selected text
function getContextText(selectedText) {
    try {
        // Try to find the selected text in the document with broader selectors
        const textNodes = [
            ...document.querySelectorAll("p, h1, h2, h3, h4, h5, h6, li, div, span, article, section"),
        ].filter((node) => node.textContent && node.textContent.includes(selectedText));
        if (textNodes.length === 0) {
            return undefined;
        }
        // Use the first matching element as context
        const contextNode = textNodes[0];
        const fullText = contextNode.textContent || "";
        // Also get context from the parent element if available
        let parentText = "";
        const parentNode = contextNode.parentElement;
        if (parentNode && parentNode.textContent) {
            parentText = parentNode.textContent;
        }
        // Use the longer text between the element's text and its parent's text
        let contextText = fullText;
        if (parentText.length > fullText.length && parentText.length < 5000) {
            contextText = parentText;
        }
        // Return surrounding context, doubling the limit from 500 to 1000 characters
        if (contextText.length > 1000) {
            return contextText.substring(0, 1000); // Double the previous limit of 500
        }
        return contextText;
    }
    catch (error) {
        console.error("Error getting context text:", error);
        return selectedText; // Fallback to just the selected text
    }
}
// Create the tooltip element
function createTooltip(text) {
    console.log("Creating tooltip for:", text);
    // Remove any existing tooltip
    removeTooltip();
    // Create new tooltip
    const tooltip = document.createElement("div");
    tooltip.className = "ai-dictionary-tooltip";
    // Header
    const header = document.createElement("div");
    header.className = "ai-dictionary-header";
    const title = document.createElement("div");
    title.className = "ai-dictionary-title";
    // Add drag handle icon
    const dragHandle = document.createElement("span");
    dragHandle.className = "ai-dictionary-drag-handle";
    dragHandle.textContent = "⋮⋮"; // Vertical dots to indicate draggable
    title.appendChild(dragHandle);
    const titleText = document.createElement("span");
    titleText.textContent = "AI Dictionary+";
    title.appendChild(titleText);
    header.appendChild(title);
    const closeButton = document.createElement("button");
    closeButton.className = "ai-dictionary-close";
    closeButton.textContent = "✕";
    closeButton.addEventListener("click", removeTooltip);
    header.appendChild(closeButton);
    // Add drag functionality
    header.addEventListener("mousedown", (e) => {
        if (e.button !== 0)
            return; // Only handle left mouse button
        e.preventDefault();
        const tooltipRect = tooltip.getBoundingClientRect();
        dragState = {
            isDragging: true,
            startX: e.clientX,
            startY: e.clientY,
            tooltipX: tooltipRect.left,
            tooltipY: tooltipRect.top,
        };
        tooltip.classList.add("dragging");
        // Add temporary event listeners for drag and drop
        document.addEventListener("mousemove", handleDrag);
        document.addEventListener("mouseup", handleDrop);
    });
    tooltip.appendChild(header);
    // Content area
    const content = document.createElement("div");
    content.className = "ai-dictionary-content";
    tooltip.appendChild(content);
    // Position tooltip
    if (!hasBeenMoved) {
        positionTooltipNearSelection(tooltip, window.getSelection());
    }
    else {
        // Use the last known position
        const lastTooltip = activeTooltip;
        if (lastTooltip) {
            tooltip.style.left = lastTooltip.style.left;
            tooltip.style.top = lastTooltip.style.top;
        }
        else {
            positionTooltipCenter(tooltip);
        }
    }
    // Apply the theme
    applyTheme(tooltip);
    // Add to document body
    document.body.appendChild(tooltip);
    console.log("Tooltip added to document.body");
    activeTooltip = tooltip;
    return tooltip;
}
// Handle drag movement
function handleDrag(e) {
    if (!dragState || !activeTooltip)
        return;
    const deltaX = e.clientX - dragState.startX;
    const deltaY = e.clientY - dragState.startY;
    // Calculate new position
    let newX = dragState.tooltipX + deltaX;
    let newY = dragState.tooltipY + deltaY;
    // Get tooltip dimensions
    const tooltipRect = activeTooltip.getBoundingClientRect();
    const tooltipWidth = tooltipRect.width;
    const tooltipHeight = tooltipRect.height;
    // Keep tooltip within viewport bounds
    newX = Math.max(10, Math.min(newX, window.innerWidth - tooltipWidth - 10));
    newY = Math.max(10, Math.min(newY, window.innerHeight - tooltipHeight - 10));
    // Update tooltip position
    activeTooltip.style.left = `${newX}px`;
    activeTooltip.style.top = `${newY}px`;
    hasBeenMoved = true;
}
// Handle drop
function handleDrop() {
    if (!activeTooltip)
        return;
    activeTooltip.classList.remove("dragging");
    dragState = null;
    // Remove temporary event listeners
    document.removeEventListener("mousemove", handleDrag);
    document.removeEventListener("mouseup", handleDrop);
}
// When removing tooltip, reset the hasBeenMoved flag
function removeTooltip() {
    if (activeTooltip) {
        activeTooltip.remove();
        activeTooltip = null;
        hasBeenMoved = false;
    }
}
// Apply theme based on settings
function applyTheme(element) {
    return __awaiter(this, void 0, void 0, function* () {
        const settings = yield (0, utils_1.getSettings)();
        const theme = (0, utils_1.getTheme)(settings);
        if (theme === "dark") {
            element.classList.add("dark-theme");
        }
        else {
            element.classList.remove("dark-theme");
        }
    });
}
// Show loading state
function showLoadingState(tooltip) {
    const content = tooltip.querySelector(".ai-dictionary-content");
    if (!content)
        return;
    content.innerHTML = "";
    const loading = document.createElement("div");
    loading.className = "ai-dictionary-loading";
    const spinner = document.createElement("div");
    spinner.className = "ai-dictionary-spinner";
    loading.appendChild(spinner);
    const text = document.createElement("span");
    text.textContent = "Getting explanation...";
    loading.appendChild(text);
    content.appendChild(loading);
}
// Show error message
function showError(tooltip, errorMessage) {
    const content = tooltip.querySelector(".ai-dictionary-content");
    if (!content)
        return;
    content.innerHTML = "";
    const error = document.createElement("div");
    error.className = "ai-dictionary-error";
    error.textContent = `Error: ${errorMessage}`;
    content.appendChild(error);
}
// Show explanation
function showExplanation(result, tooltip) {
    if (!tooltip) {
        tooltip = activeTooltip || createTooltip(result.originalText);
    }
    const content = tooltip.querySelector(".ai-dictionary-content");
    if (!content)
        return;
    // Store conversation history
    activeText = result.originalText;
    activeConversationHistory = result.conversationHistory;
    // Clear content
    content.innerHTML = "";
    // Add explanation text with markdown rendering
    const explanationText = document.createElement("div");
    explanationText.className = "ai-dictionary-markdown";
    // Render markdown content safely
    try {
        explanationText.innerHTML = marked_1.marked.parse(result.explanation);
    }
    catch (error) {
        console.error("Error parsing markdown:", error);
        explanationText.textContent = result.explanation;
    }
    // Add copy button
    const copyButtonContainer = document.createElement("div");
    copyButtonContainer.className = "ai-dictionary-copy-container";
    const copyButton = document.createElement("button");
    copyButton.className = "ai-dictionary-copy-button";
    copyButton.title = "Copy explanation to clipboard";
    copyButton.innerHTML = `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
      <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
    </svg>
  `;
    // Add tooltip text that shows on hover
    const tooltipText = document.createElement("span");
    tooltipText.className = "ai-dictionary-tooltip-text";
    tooltipText.textContent = "Copied!";
    copyButton.appendChild(tooltipText);
    // Add click event to copy the explanation text
    copyButton.addEventListener("click", () => {
        // Create a temporary textarea to hold the text
        const textarea = document.createElement("textarea");
        textarea.value = result.explanation;
        document.body.appendChild(textarea);
        textarea.select();
        try {
            // Copy the text
            document.execCommand("copy");
            // Show the copied tooltip
            tooltipText.classList.add("show");
            // Hide the tooltip after 2 seconds
            setTimeout(() => {
                tooltipText.classList.remove("show");
            }, 2000);
        }
        catch (err) {
            console.error("Error copying text:", err);
        }
        finally {
            document.body.removeChild(textarea);
        }
    });
    copyButtonContainer.appendChild(copyButton);
    explanationText.appendChild(copyButtonContainer);
    content.appendChild(explanationText);
    // Add citations if available
    if (result.webSearched && result.citations && result.citations.length > 0) {
        const citationsContainer = document.createElement("div");
        citationsContainer.className = "ai-dictionary-citations";
        const citationsTitle = document.createElement("div");
        citationsTitle.className = "ai-dictionary-citations-title";
        citationsTitle.textContent = "Sources";
        citationsContainer.appendChild(citationsTitle);
        const citationsList = document.createElement("ul");
        result.citations.forEach((citation) => {
            const citationItem = document.createElement("li");
            // Try to extract domain from URL for cleaner display
            try {
                const url = new URL(citation);
                const domain = url.hostname.replace("www.", "");
                const citationLink = document.createElement("a");
                citationLink.href = citation;
                citationLink.textContent = domain;
                citationLink.target = "_blank";
                citationLink.rel = "noopener noreferrer";
                citationItem.appendChild(citationLink);
            }
            catch (e) {
                // If URL parsing fails, just show the raw citation
                citationItem.textContent = citation;
            }
            citationsList.appendChild(citationItem);
        });
        citationsContainer.appendChild(citationsList);
        content.appendChild(citationsContainer);
    }
    // Remove any existing follow-up area before creating a new one
    const existingFollowUp = tooltip.querySelector(".ai-dictionary-follow-up");
    if (existingFollowUp) {
        tooltip.removeChild(existingFollowUp);
    }
    // Add follow-up area
    const followUp = document.createElement("div");
    followUp.className = "ai-dictionary-follow-up";
    const input = document.createElement("input");
    input.className = "ai-dictionary-input";
    input.type = "text";
    input.placeholder = "Ask a follow-up question...";
    followUp.appendChild(input);
    const buttons = document.createElement("div");
    buttons.className = "ai-dictionary-buttons";
    const submitButton = document.createElement("button");
    submitButton.className = "ai-dictionary-submit";
    submitButton.textContent = "Ask";
    submitButton.addEventListener("click", () => {
        if (input.value.trim()) {
            handleFollowUpQuestion(input.value.trim(), tooltip);
        }
    });
    buttons.appendChild(submitButton);
    // Only add web search button if it's enabled and not already searched
    if ((userSettings === null || userSettings === void 0 ? void 0 : userSettings.webSearchEnabled) &&
        (userSettings === null || userSettings === void 0 ? void 0 : userSettings.perplexityApiKey) &&
        !result.webSearched) {
        const webSearchButton = document.createElement("button");
        webSearchButton.className = "ai-dictionary-web-search";
        webSearchButton.textContent = "Search Web";
        webSearchButton.addEventListener("click", () => {
            handleWebSearch(result.originalText, result.explanation);
        });
        buttons.appendChild(webSearchButton);
    }
    const chatButton = document.createElement("button");
    chatButton.className = "ai-dictionary-chat";
    chatButton.textContent = "Continue in Chat";
    chatButton.addEventListener("click", () => {
        openChatPage();
    });
    buttons.appendChild(chatButton);
    // Add regenerate button
    const regenerateButton = document.createElement("button");
    regenerateButton.className = "ai-dictionary-regenerate";
    regenerateButton.textContent = "Regenerate";
    regenerateButton.title = "Get a fresh explanation (bypass cache)";
    regenerateButton.addEventListener("click", () => {
        handleRegenerateExplanation(result.originalText, getContextText(result.originalText));
    });
    buttons.appendChild(regenerateButton);
    followUp.appendChild(buttons);
    // Add event listener for enter key
    input.addEventListener("keydown", (event) => {
        if (event.key === "Enter" && input.value.trim()) {
            handleFollowUpQuestion(input.value.trim(), tooltip);
        }
    });
    tooltip.appendChild(followUp);
    // Focus on the input field
    setTimeout(() => {
        input.focus();
    }, 100);
}
// Handle follow-up question
function handleFollowUpQuestion(question, tooltip) {
    // Show loading state
    showLoadingState(tooltip);
    // Clear the input
    const input = tooltip.querySelector(".ai-dictionary-input");
    if (input) {
        input.value = "";
    }
    // Send follow-up request
    chrome.runtime.sendMessage({
        type: types_1.MessageType.FOLLOW_UP_QUESTION,
        payload: {
            originalText: activeText,
            question,
            conversationHistory: activeConversationHistory,
        },
    }, (response) => {
        if (chrome.runtime.lastError) {
            console.error("Error sending message:", chrome.runtime.lastError);
            showError(tooltip, "Error communicating with the extension.");
            return;
        }
        if (response.error) {
            showError(tooltip, response.error);
            return;
        }
        // Update UI with explanation
        showExplanation(response, tooltip);
    });
}
// Open the chat page with the current conversation context
function openChatPage() {
    // Prepare data to send to the chat page
    const chatData = {
        originalText: activeText,
        conversationHistory: activeConversationHistory,
    };
    // Encode the data for URL transmission
    const encodedData = encodeURIComponent(JSON.stringify(chatData));
    const chatUrl = chrome.runtime.getURL(`chat.html?data=${encodedData}`);
    // Notify the background script (useful for future features)
    chrome.runtime.sendMessage({
        type: types_1.MessageType.OPEN_CHAT,
        payload: chatData,
    });
    // Open the chat in a new tab using window.open() which is available in content scripts
    window.open(chatUrl, "_blank");
}
// Listen for clicks outside the tooltip to close it
document.addEventListener("click", (event) => {
    if (activeTooltip &&
        event.target instanceof Node &&
        !activeTooltip.contains(event.target) &&
        (!selectionButton || !selectionButton.contains(event.target))) {
        removeTooltip();
    }
});
// Handle web search request
function handleWebSearch(originalText, originalExplanation) {
    if (!activeTooltip)
        return;
    // Show loading state
    showLoadingState(activeTooltip);
    // Send request to background script
    console.log("Sending web search request to background script");
    chrome.runtime.sendMessage({
        type: types_1.MessageType.WEB_SEARCH,
        payload: {
            text: originalText,
            originalExplanation,
        },
    }, (response) => {
        console.log("Received web search response:", response);
        if (chrome.runtime.lastError) {
            console.error("Error sending message:", chrome.runtime.lastError);
            showError(activeTooltip, "Error communicating with the extension.");
            return;
        }
        if (response.error) {
            console.error("Error in response:", response.error);
            showError(activeTooltip, response.error);
            return;
        }
        // Update UI with enhanced explanation
        showExplanation(response, activeTooltip);
    });
}
// Function to show web search results
function showWebSearchResult(result) {
    // Just use the existing showExplanation function
    showExplanation(result);
}
// Function to regenerate explanation without using the cache
function handleRegenerateExplanation(originalText, contextText) {
    // Create loading tooltip
    const tooltip = createTooltip(originalText);
    // Make the tooltip very visible
    tooltip.style.border = "2px solid #4285f4";
    tooltip.style.boxShadow = "0 4px 20px rgba(0, 0, 0, 0.3)";
    showLoadingState(tooltip);
    // Send request to background script with skipCache flag
    console.log("Sending regenerate request to background script");
    chrome.runtime.sendMessage({
        type: types_1.MessageType.EXPLAIN_TEXT,
        payload: {
            text: originalText,
            contextText: contextText,
            skipCache: true, // Skip cache to get a fresh explanation
            pageUrl: window.location.href, // Add the current page URL
        },
    }, (response) => {
        console.log("Received response from background script:", response);
        if (chrome.runtime.lastError) {
            console.error("Error sending message:", chrome.runtime.lastError);
            showError(tooltip, "Error communicating with the extension.");
            return;
        }
        if (response.error) {
            console.error("Error in response:", response.error);
            showError(tooltip, response.error);
            return;
        }
        console.log("Showing regenerated explanation in tooltip");
        // Update UI with explanation
        showExplanation(response, tooltip);
    });
}
// Handle media explanation request
function handleMediaExplainRequest(mediaType, mediaUrl, pageUrl) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            console.log(`Handling ${mediaType} explanation request for ${mediaUrl}`);
            // Create a tooltip for the media
            const tooltip = createMediaTooltip(mediaType, mediaUrl);
            document.body.appendChild(tooltip);
            // Position the tooltip near the media element
            const mediaElement = findMediaElement(mediaType, mediaUrl);
            positionTooltip(tooltip, mediaElement);
            // Show loading state
            showLoadingState(tooltip);
            // Get context text if available
            const contextText = getContextTextForMedia(mediaElement, mediaUrl);
            // Get media data as base64 or URL
            const mediaData = yield getMediaData(mediaType, mediaUrl);
            // Get MIME type based on media type and URL
            const mimeType = getMimeType(mediaType, mediaUrl);
            // Get timestamp if it's a video
            const timestamp = mediaType === types_1.MediaType.VIDEO
                ? getCurrentVideoTimestamp(mediaUrl)
                : undefined;
            // Create request payload
            const request = {
                mediaType,
                mediaData,
                mimeType,
                contextText,
                tabId: undefined, // Will be set by the background script
                pageUrl,
                timestamp,
            };
            // Send request to background script
            const result = yield chrome.runtime.sendMessage({
                type: types_1.MessageType.EXPLAIN_MEDIA,
                payload: request,
            });
            // Display the result
            showMediaExplanation(result, tooltip);
        }
        catch (error) {
            console.error(`Error handling ${mediaType} explanation:`, error);
            // Create error tooltip if none exists
            if (!activeTooltip) {
                const tooltip = createMediaTooltip(mediaType, mediaUrl);
                document.body.appendChild(tooltip);
                // Position near the media if possible
                const mediaElement = findMediaElement(mediaType, mediaUrl);
                positionTooltip(tooltip, mediaElement);
            }
            // Show error message with helpful information
            const errorMessage = error instanceof Error ? error.message : String(error);
            let userFriendlyMessage = "An error occurred while processing the media.";
            // Add more specific error details based on media type
            if (mediaType === types_1.MediaType.IMAGE) {
                userFriendlyMessage = "Failed to analyze the image. This may be due to:";
                userFriendlyMessage += "\n\n• The image is protected by the website";
                userFriendlyMessage += "\n• The image is too large";
                userFriendlyMessage += "\n• There are network connectivity issues";
                userFriendlyMessage +=
                    "\n\nPlease try downloading the image and using a local file instead.";
            }
            else if (mediaType === types_1.MediaType.VIDEO) {
                userFriendlyMessage =
                    "Failed to analyze the video. The Gemini API has specific requirements for video processing:\n\n" +
                        "• Videos must be uploaded through the Gemini File API\n" +
                        "• Video size should be under 200MB\n" +
                        "• Video duration should be under 30 minutes\n" +
                        "• Supported formats include MP4, MOV, and WebM\n" +
                        "• The video URL must be publicly accessible\n\n" +
                        "You may also try with a shorter video or a different video hosting service.";
            }
            else if (mediaType === types_1.MediaType.AUDIO) {
                userFriendlyMessage =
                    "Failed to analyze the audio. This may be due to restricted access or an unsupported format.";
            }
            else if (mediaType === types_1.MediaType.DOCUMENT) {
                userFriendlyMessage =
                    "Failed to analyze the document. This may be due to restricted access or an unsupported format.";
            }
            // Add technical details for debugging
            userFriendlyMessage += `\n\nTechnical details: ${errorMessage}`;
            showError(activeTooltip, userFriendlyMessage);
        }
    });
}
// Create a tooltip for media content
function createMediaTooltip(mediaType, mediaUrl) {
    // Remove any existing tooltip
    if (activeTooltip) {
        removeTooltip();
    }
    // Create tooltip element
    const tooltip = document.createElement("div");
    tooltip.className = "ai-dictionary-tooltip";
    tooltip.setAttribute("data-media-type", mediaType);
    tooltip.setAttribute("data-media-url", mediaUrl);
    // Add header
    const header = document.createElement("div");
    header.className = "ai-dictionary-header";
    // Add title based on media type
    const title = document.createElement("div");
    title.className = "ai-dictionary-title";
    switch (mediaType) {
        case types_1.MediaType.IMAGE:
            title.textContent = "Image Explanation";
            break;
        case types_1.MediaType.VIDEO:
            title.textContent = "Video Explanation";
            break;
        case types_1.MediaType.AUDIO:
            title.textContent = "Audio Explanation";
            break;
        case types_1.MediaType.DOCUMENT:
            title.textContent = "Document Explanation";
            break;
        default:
            title.textContent = "Content Explanation";
    }
    header.appendChild(title);
    // Add close button
    const closeButton = document.createElement("button");
    closeButton.className = "ai-dictionary-close";
    closeButton.textContent = "✕";
    closeButton.addEventListener("click", removeTooltip);
    header.appendChild(closeButton);
    tooltip.appendChild(header);
    // Add content container
    const content = document.createElement("div");
    content.className = "ai-dictionary-content";
    tooltip.appendChild(content);
    // Add footer
    const footer = document.createElement("div");
    footer.className = "ai-dictionary-footer";
    footer.textContent = "AI Dictionary+";
    tooltip.appendChild(footer);
    // Store as active tooltip
    activeTooltip = tooltip;
    // Apply appropriate theme
    applyTheme(tooltip);
    return tooltip;
}
// Find media element in the DOM based on its URL
function findMediaElement(mediaType, mediaUrl) {
    let selector = "";
    switch (mediaType) {
        case types_1.MediaType.IMAGE:
            selector = `img[src="${mediaUrl}"]`;
            break;
        case types_1.MediaType.VIDEO:
            selector = `video[src="${mediaUrl}"], video source[src="${mediaUrl}"]`;
            break;
        case types_1.MediaType.AUDIO:
            selector = `audio[src="${mediaUrl}"], audio source[src="${mediaUrl}"]`;
            break;
        default:
            return null;
    }
    const element = document.querySelector(selector);
    // If we found a source element, get its parent
    if (element && element.tagName.toLowerCase() === "source") {
        return element.parentElement;
    }
    return element;
}
// Position tooltip near a media element
function positionTooltip(tooltip, targetElement) {
    // If we have a target element, position near it
    if (targetElement) {
        const rect = targetElement.getBoundingClientRect();
        // Set initial position
        tooltip.style.position = "fixed";
        tooltip.style.zIndex = "9999";
        // Position at the bottom right of the target element
        tooltip.style.top = `${rect.bottom + window.scrollY}px`;
        tooltip.style.left = `${rect.right + window.scrollX - tooltip.offsetWidth}px`;
        // If tooltip would overflow window, reposition
        setTimeout(() => {
            const tooltipRect = tooltip.getBoundingClientRect();
            // If it's beyond the right edge, align with the left edge of the target
            if (tooltipRect.right > window.innerWidth) {
                tooltip.style.left = `${rect.left + window.scrollX}px`;
            }
            // If it extends below the window, position above the target
            if (tooltipRect.bottom > window.innerHeight) {
                tooltip.style.top = `${rect.top + window.scrollY - tooltip.offsetHeight}px`;
            }
        }, 0);
    }
    else {
        // If no target element, position in the center
        tooltip.style.position = "fixed";
        tooltip.style.zIndex = "9999";
        tooltip.style.top = "50%";
        tooltip.style.left = "50%";
        tooltip.style.transform = "translate(-50%, -50%)";
    }
}
// Get context text for media element
function getContextTextForMedia(mediaElement, mediaUrl) {
    if (!mediaElement)
        return undefined;
    // Get alt text for images
    if (mediaElement.tagName.toLowerCase() === "img") {
        const img = mediaElement;
        if (img.alt)
            return `Image alt text: ${img.alt}`;
    }
    // Get surrounding caption, figcaption, or nearby text
    const parent = mediaElement.parentElement;
    if (!parent)
        return undefined;
    // Check for figcaption
    const figcaption = parent.querySelector("figcaption");
    if (figcaption)
        return figcaption.textContent || undefined;
    // Check for aria-label
    const ariaLabel = mediaElement.getAttribute("aria-label");
    if (ariaLabel)
        return `Element label: ${ariaLabel}`;
    // Get nearby text content
    const siblings = Array.from(parent.childNodes);
    const textSiblings = siblings.filter((node) => node.nodeType === Node.TEXT_NODE &&
        node.textContent &&
        node.textContent.trim().length > 0);
    if (textSiblings.length > 0) {
        return textSiblings
            .map((node) => node.textContent)
            .join(" ")
            .trim()
            .substring(0, 200);
    }
    // Get parent's text if nothing else
    const parentText = parent.textContent || "";
    if (parentText.length > 0) {
        return parentText.trim().substring(0, 200);
    }
    return undefined;
}
// Get current timestamp for video
function getCurrentVideoTimestamp(videoUrl) {
    const videoElement = document.querySelector(`video[src="${videoUrl}"]`);
    if (!videoElement) {
        // Try to find video with this URL in a source element
        const sourceElement = document.querySelector(`video source[src="${videoUrl}"]`);
        if (sourceElement) {
            const parentVideo = sourceElement.closest("video");
            if (parentVideo) {
                return Math.floor(parentVideo.currentTime);
            }
        }
        return undefined;
    }
    return Math.floor(videoElement.currentTime);
}
// Get MIME type from URL or media element
function getMimeType(mediaType, mediaUrl) {
    var _a;
    // Default MIME types based on media type
    const defaultMimeTypes = {
        [types_1.MediaType.IMAGE]: "image/jpeg",
        [types_1.MediaType.VIDEO]: "video/mp4",
        [types_1.MediaType.AUDIO]: "audio/mpeg",
        [types_1.MediaType.DOCUMENT]: "application/pdf",
        [types_1.MediaType.TEXT]: "text/plain",
    };
    // Try to determine from URL extension
    const extension = (_a = mediaUrl.split(".").pop()) === null || _a === void 0 ? void 0 : _a.toLowerCase();
    if (extension) {
        switch (extension) {
            // Images
            case "jpg":
            case "jpeg":
                return "image/jpeg";
            case "png":
                return "image/png";
            case "gif":
                return "image/gif";
            case "webp":
                return "image/webp";
            case "svg":
                return "image/svg+xml";
            // Videos
            case "mp4":
                return "video/mp4";
            case "webm":
                return "video/webm";
            case "ogg":
                return "video/ogg";
            case "mov":
                return "video/quicktime";
            // Audio
            case "mp3":
                return "audio/mpeg";
            case "wav":
                return "audio/wav";
            case "aac":
                return "audio/aac";
            case "flac":
                return "audio/flac";
            // Documents
            case "pdf":
                return "application/pdf";
            case "doc":
            case "docx":
                return "application/msword";
            case "txt":
                return "text/plain";
        }
    }
    // If we couldn't determine from extension, find element and check its type
    const mediaElement = findMediaElement(mediaType, mediaUrl);
    if (mediaElement) {
        if (mediaElement.tagName.toLowerCase() === "img") {
            // For images, we could potentially use new Image() to load it and check naturalWidth/naturalHeight
            // but for simplicity, we'll use the default
            return defaultMimeTypes[types_1.MediaType.IMAGE];
        }
        else if (mediaElement.tagName.toLowerCase() === "video") {
            // For video, check the type attribute of the source element
            const sourceElement = mediaElement.querySelector(`source[src="${mediaUrl}"]`);
            if (sourceElement && sourceElement.getAttribute("type")) {
                return (sourceElement.getAttribute("type") ||
                    defaultMimeTypes[types_1.MediaType.VIDEO]);
            }
        }
        else if (mediaElement.tagName.toLowerCase() === "audio") {
            // For audio, check the type attribute of the source element
            const sourceElement = mediaElement.querySelector(`source[src="${mediaUrl}"]`);
            if (sourceElement && sourceElement.getAttribute("type")) {
                return (sourceElement.getAttribute("type") ||
                    defaultMimeTypes[types_1.MediaType.AUDIO]);
            }
        }
    }
    // Fallback to default MIME type for this media type
    return defaultMimeTypes[mediaType];
}
// Get media data as base64 or URL
function getMediaData(mediaType, mediaUrl) {
    return __awaiter(this, void 0, void 0, function* () {
        // Simply return the URL for all media types including images
        // The background script will handle conversion to base64 when needed
        return mediaUrl;
    });
}
// Show media explanation result
function showMediaExplanation(result, tooltip) {
    console.log("Showing media explanation:", result);
    // If no tooltip provided, use active tooltip
    if (!tooltip && !activeTooltip) {
        console.error("No tooltip available to show explanation");
        return;
    }
    const targetTooltip = tooltip || activeTooltip;
    // Update conversation history
    activeConversationHistory = result.conversationHistory || [];
    // If there's an error, show error message
    if (result.error) {
        showError(targetTooltip, result.error);
        return;
    }
    // Get content container
    const contentContainer = targetTooltip.querySelector(".ai-dictionary-content");
    if (!contentContainer) {
        console.error("Content container not found in tooltip");
        return;
    }
    // Clear any loading indicator
    contentContainer.innerHTML = "";
    // Create explanation text element
    const explanationElement = document.createElement("div");
    explanationElement.className = "ai-dictionary-explanation markdown-content";
    // Parse markdown and set as HTML
    explanationElement.innerHTML = marked_1.marked.parse(result.explanation);
    contentContainer.appendChild(explanationElement);
    // Add action buttons
    const actionsContainer = document.createElement("div");
    actionsContainer.className = "ai-dictionary-actions";
    // Add "Continue in Chat" button
    const chatButton = document.createElement("button");
    chatButton.className = "ai-dictionary-chat";
    chatButton.textContent = "Continue in Chat";
    chatButton.addEventListener("click", openChatPage);
    actionsContainer.appendChild(chatButton);
    // Add "Copy" button
    const copyButton = document.createElement("button");
    copyButton.className = "ai-dictionary-copy-button";
    copyButton.textContent = "Copy";
    copyButton.addEventListener("click", () => {
        navigator.clipboard.writeText(result.explanation).then(() => {
            const originalText = copyButton.textContent;
            copyButton.textContent = "Copied!";
            setTimeout(() => {
                copyButton.textContent = originalText;
            }, 2000);
        });
    });
    actionsContainer.appendChild(copyButton);
    // Add "Regenerate" button
    const regenerateButton = document.createElement("button");
    regenerateButton.className = "ai-dictionary-regenerate";
    regenerateButton.textContent = "Regenerate";
    regenerateButton.addEventListener("click", () => {
        const mediaType = targetTooltip.getAttribute("data-media-type");
        const mediaUrl = targetTooltip.getAttribute("data-media-url") || "";
        if (mediaType && mediaUrl) {
            handleMediaExplainRequest(mediaType, mediaUrl, window.location.href);
        }
    });
    actionsContainer.appendChild(regenerateButton);
    contentContainer.appendChild(actionsContainer);
    // Add follow-up area if not already present
    const existingFollowUp = targetTooltip.querySelector(".ai-dictionary-follow-up-area");
    if (!existingFollowUp) {
        const followUpArea = document.createElement("div");
        followUpArea.className = "ai-dictionary-follow-up-area";
        const followUpInput = document.createElement("input");
        followUpInput.className = "ai-dictionary-follow-up-input";
        followUpInput.placeholder = "Ask a follow-up question...";
        followUpInput.type = "text";
        followUpInput.addEventListener("keydown", (event) => {
            if (event.key === "Enter") {
                const question = followUpInput.value.trim();
                if (question) {
                    handleFollowUpQuestion(question, targetTooltip);
                    followUpInput.value = "";
                }
            }
        });
        // Add submit button for follow-up
        const submitButton = document.createElement("button");
        submitButton.className = "ai-dictionary-submit";
        submitButton.textContent = "Ask";
        submitButton.addEventListener("click", () => {
            const question = followUpInput.value.trim();
            if (question) {
                handleFollowUpQuestion(question, targetTooltip);
                followUpInput.value = "";
            }
        });
        // Add submit button to a button container
        const followUpButtons = document.createElement("div");
        followUpButtons.className = "ai-dictionary-buttons";
        followUpButtons.appendChild(submitButton);
        followUpArea.appendChild(followUpInput);
        followUpArea.appendChild(followUpButtons);
        contentContainer.appendChild(followUpArea);
        // Focus the input
        setTimeout(() => {
            followUpInput.focus();
        }, 100);
    }
    // Make sure tooltip is visible
    targetTooltip.style.display = "block";
    // Adjust position if needed
    if (targetTooltip === activeTooltip) {
        const mediaType = targetTooltip.getAttribute("data-media-type");
        const mediaUrl = targetTooltip.getAttribute("data-media-url") || "";
        const mediaElement = findMediaElement(mediaType, mediaUrl);
        if (mediaElement) {
            positionTooltip(targetTooltip, mediaElement);
        }
    }
}
// Handle multimodal request (text + media)
function handleMultimodalRequest() {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            console.log("Handling multimodal request");
            if (!pendingMultimodalSelection.text ||
                !pendingMultimodalSelection.mediaType ||
                !pendingMultimodalSelection.mediaUrl) {
                console.error("Missing required text or media for multimodal request");
                return;
            }
            // Create a tooltip for the multimodal content
            const tooltip = createMultimodalTooltip(pendingMultimodalSelection.text, pendingMultimodalSelection.mediaType, pendingMultimodalSelection.mediaUrl);
            document.body.appendChild(tooltip);
            // Position the tooltip
            positionTooltipForMultimodal(tooltip);
            // Show loading state
            showLoadingState(tooltip);
            // Get media data
            const mediaData = yield getMediaData(pendingMultimodalSelection.mediaType, pendingMultimodalSelection.mediaUrl);
            // Get MIME type
            const mimeType = getMimeType(pendingMultimodalSelection.mediaType, pendingMultimodalSelection.mediaUrl);
            // Get timestamp if it's a video
            const timestamp = pendingMultimodalSelection.mediaType === types_1.MediaType.VIDEO
                ? getCurrentVideoTimestamp(pendingMultimodalSelection.mediaUrl)
                : undefined;
            // Get media context text if available
            const mediaContextText = getContextTextForMedia(pendingMultimodalSelection.mediaElement, pendingMultimodalSelection.mediaUrl);
            // Create request payload
            const request = {
                text: pendingMultimodalSelection.text,
                contextText: pendingMultimodalSelection.textContext || undefined,
                mediaType: pendingMultimodalSelection.mediaType,
                mediaData,
                mimeType,
                mediaContextText,
                tabId: undefined, // Will be set by the background script
                pageUrl: window.location.href,
                timestamp,
            };
            // Send request to background script
            console.log("Sending multimodal request to background script:", request);
            const result = yield chrome.runtime.sendMessage({
                type: types_1.MessageType.EXPLAIN_MULTIMODAL,
                payload: request,
            });
            // Display the result
            showMediaExplanation(result, tooltip);
            // Don't reset multimodal selection state immediately
            // This allows the user to try different approaches with the same selection
            // Schedule cleanup for later (30 seconds)
            setTimeout(() => {
                // Only reset if no tooltip is active (user isn't still interacting)
                if (!activeTooltip) {
                    resetMultimodalSelection();
                }
            }, 30000);
        }
        catch (error) {
            console.error("Error handling multimodal request:", error);
            // Show error message
            if (activeTooltip) {
                const errorMessage = error instanceof Error ? error.message : String(error);
                // Get content container
                const contentContainer = activeTooltip.querySelector(".ai-dictionary-content");
                if (!contentContainer) {
                    console.error("Content container not found in tooltip");
                    return;
                }
                // Clear loading state
                contentContainer.innerHTML = "";
                // Create error message
                const errorElement = document.createElement("div");
                errorElement.className = "ai-dictionary-error";
                errorElement.innerHTML = `
        <p>Failed to process the combined text and media content:</p>
        <p class="ai-dictionary-error-details">${errorMessage}</p>
        <p>You can try one of the following options:</p>
      `;
                contentContainer.appendChild(errorElement);
                // Create action buttons
                const actionContainer = document.createElement("div");
                actionContainer.className = "ai-dictionary-error-actions";
                actionContainer.style.display = "flex";
                actionContainer.style.gap = "8px";
                actionContainer.style.marginTop = "12px";
                // Retry button
                const retryButton = document.createElement("button");
                retryButton.className = "ai-dictionary-retry";
                retryButton.textContent = "Retry";
                retryButton.addEventListener("click", () => {
                    removeTooltip();
                    // Small delay to allow UI to clear
                    setTimeout(() => {
                        handleMultimodalRequest();
                    }, 100);
                });
                actionContainer.appendChild(retryButton);
                // Text-only button
                const textButton = document.createElement("button");
                textButton.className = "ai-dictionary-text-only";
                textButton.textContent = "Explain Text Only";
                textButton.addEventListener("click", () => {
                    removeTooltip();
                    // Small delay to allow UI to clear
                    setTimeout(() => {
                        handleExplainRequest(pendingMultimodalSelection.text);
                    }, 100);
                });
                actionContainer.appendChild(textButton);
                // Media-only button
                const mediaButton = document.createElement("button");
                mediaButton.className = "ai-dictionary-media-only";
                mediaButton.textContent = `Explain ${pendingMultimodalSelection.mediaType} Only`;
                mediaButton.addEventListener("click", () => {
                    removeTooltip();
                    // Small delay to allow UI to clear
                    setTimeout(() => {
                        handleMediaExplainRequest(pendingMultimodalSelection.mediaType, pendingMultimodalSelection.mediaUrl, window.location.href);
                    }, 100);
                });
                actionContainer.appendChild(mediaButton);
                contentContainer.appendChild(actionContainer);
            }
            // Do NOT reset multimodal selection state
            // This allows user to retry or choose an alternative
        }
    });
}
/**
 * Creates a tooltip for multimodal content (combined text and media)
 */
function createMultimodalTooltip(text, mediaType, mediaUrl) {
    const tooltip = document.createElement("div");
    tooltip.className = "ai-dictionary-tooltip ai-dictionary-multimodal-tooltip";
    tooltip.style.visibility = "hidden";
    // Create header
    const header = document.createElement("div");
    header.className = "ai-dictionary-header";
    // Create title
    const title = document.createElement("div");
    title.className = "ai-dictionary-title";
    title.textContent = `Text & ${mediaType.charAt(0).toUpperCase() + mediaType.slice(1)} Explanation`;
    header.appendChild(title);
    // Create close button
    const closeButton = document.createElement("button");
    closeButton.className = "ai-dictionary-close";
    closeButton.textContent = "×";
    closeButton.addEventListener("click", removeTooltip);
    header.appendChild(closeButton);
    tooltip.appendChild(header);
    // Create content container
    const content = document.createElement("div");
    content.className = "ai-dictionary-content";
    // Create selection preview
    const previewContainer = document.createElement("div");
    previewContainer.className = "ai-dictionary-selection-preview";
    previewContainer.style.display = "flex";
    previewContainer.style.marginBottom = "12px";
    previewContainer.style.padding = "8px";
    previewContainer.style.backgroundColor = "rgba(0, 0, 0, 0.05)";
    previewContainer.style.borderRadius = "4px";
    // Create text preview
    const textPreview = document.createElement("div");
    textPreview.className = "ai-dictionary-text-preview";
    textPreview.style.flex = "1";
    textPreview.style.marginRight = "8px";
    textPreview.style.fontStyle = "italic";
    textPreview.innerHTML = `<strong>Selected text:</strong> ${truncateText(text, 100)}`;
    previewContainer.appendChild(textPreview);
    // Create media preview
    const mediaPreview = document.createElement("div");
    mediaPreview.className = "ai-dictionary-media-preview";
    mediaPreview.style.flex = "1";
    mediaPreview.style.fontStyle = "italic";
    // Format media URL for display
    const displayUrl = mediaUrl.length > 40 ? mediaUrl.substring(0, 37) + "..." : mediaUrl;
    mediaPreview.innerHTML = `<strong>Selected ${mediaType}:</strong> <a href="${mediaUrl}" target="_blank">${displayUrl}</a>`;
    previewContainer.appendChild(mediaPreview);
    content.appendChild(previewContainer);
    tooltip.appendChild(content);
    // Add footer area for action buttons
    const footer = document.createElement("div");
    footer.className = "ai-dictionary-footer";
    tooltip.appendChild(footer);
    activeTooltip = tooltip;
    return tooltip;
}
/**
 * Position the tooltip for multimodal content
 */
function positionTooltipForMultimodal(tooltip) {
    // If we have a media element, position near it
    if (pendingMultimodalSelection.mediaElement) {
        positionTooltipNearElement(tooltip, pendingMultimodalSelection.mediaElement);
    }
    // Otherwise, position based on the text selection
    else if (pendingMultimodalSelection.selection) {
        positionTooltipNearSelection(tooltip, pendingMultimodalSelection.selection);
    }
    // Fallback to center of screen
    else {
        positionTooltipCenter(tooltip);
    }
    // Make tooltip visible after positioning
    tooltip.style.visibility = "visible";
}
/**
 * Truncate text to a specific length and add ellipsis if needed
 */
function truncateText(text, maxLength) {
    if (text.length <= maxLength) {
        return text;
    }
    return text.substring(0, maxLength - 3) + "...";
}
/**
 * Position tooltip in the center of the screen
 */
function positionTooltipCenter(tooltip) {
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;
    const tooltipWidth = Math.min(600, viewportWidth * 0.9);
    tooltip.style.width = `${tooltipWidth}px`;
    // Calculate position
    const left = (viewportWidth - tooltipWidth) / 2;
    const top = viewportHeight * 0.2; // 20% from the top
    // Apply position
    tooltip.style.left = `${left}px`;
    tooltip.style.top = `${top}px`;
}
/**
 * Position tooltip near an HTML element
 */
function positionTooltipNearElement(tooltip, element) {
    const elementRect = element.getBoundingClientRect();
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;
    // Determine tooltip size
    const tooltipWidth = Math.min(600, viewportWidth * 0.9);
    tooltip.style.width = `${tooltipWidth}px`;
    // Calculate initial position (below the element)
    let left = window.scrollX + elementRect.left;
    let top = window.scrollY + elementRect.bottom + 10;
    // Center horizontally with the element if possible
    if (elementRect.width > tooltipWidth) {
        // Element is wider than tooltip, center tooltip with element
        left =
            window.scrollX +
                elementRect.left +
                (elementRect.width - tooltipWidth) / 2;
    }
    else if (left + tooltipWidth > window.scrollX + viewportWidth - 20) {
        // Tooltip would go off-screen to the right, adjust left position
        left = window.scrollX + viewportWidth - tooltipWidth - 20;
    }
    // Ensure tooltip stays within viewport bounds (left edge)
    left = Math.max(left, window.scrollX + 20);
    // Apply position
    tooltip.style.position = "absolute";
    tooltip.style.zIndex = "9999";
    tooltip.style.left = `${left}px`;
    tooltip.style.top = `${top}px`;
    // Adjust vertical position if needed after rendering
    setTimeout(() => {
        const tooltipRect = tooltip.getBoundingClientRect();
        // Check if tooltip goes below viewport
        if (tooltipRect.bottom > viewportHeight - 20) {
            // Not enough space below, try positioning above the element
            const topPosition = window.scrollY + elementRect.top - tooltipRect.height - 10;
            // Check if there's enough space above
            if (topPosition > window.scrollY + 20) {
                tooltip.style.top = `${topPosition}px`;
            }
            else {
                // Not enough space above or below, center in viewport
                tooltip.style.top = `${window.scrollY + Math.max(100, viewportHeight * 0.1)}px`;
            }
        }
    }, 0);
}
/**
 * Position tooltip near a text selection
 */
function positionTooltipNearSelection(tooltip, selection) {
    if (!selection || !selection.rangeCount) {
        positionTooltipCenter(tooltip);
        return;
    }
    const range = selection.getRangeAt(0);
    const rect = range.getBoundingClientRect();
    // Position below the selection, with some padding
    tooltip.style.left = `${window.scrollX + Math.max(rect.left, 10)}px`;
    tooltip.style.top = `${window.scrollY + rect.bottom + 10}px`;
    // Ensure tooltip is visible in viewport - will be applied after added to DOM
    setTimeout(() => {
        const tooltipRect = tooltip.getBoundingClientRect();
        // Check if off-screen horizontally
        if (tooltipRect.right > window.innerWidth - 20) {
            tooltip.style.left = `${window.scrollX +
                Math.max(window.innerWidth - tooltipRect.width - 20, 10)}px`;
        }
        // Check if off-screen vertically
        if (tooltipRect.bottom > window.innerHeight - 20) {
            // Position above selection instead
            tooltip.style.top = `${window.scrollY + Math.max(rect.top - tooltipRect.height - 10, 10)}px`;
        }
    }, 0);
}
// Reset the multimodal selection state
function resetMultimodalSelection() {
    pendingMultimodalSelection = {
        text: null,
        textContext: null,
        mediaType: null,
        mediaUrl: null,
        mediaElement: null,
        selection: null,
    };
}
// Function to safely send messages to background
function sendBackgroundMessage(message) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!isConnected) {
            console.log("Not connected, attempting to reconnect...");
            connectToBackground();
            yield new Promise((resolve) => setTimeout(resolve, 500)); // Wait for connection
        }
        return new Promise((resolve, reject) => {
            try {
                chrome.runtime.sendMessage(message, (response) => {
                    var _a;
                    if (chrome.runtime.lastError) {
                        console.error("Error sending message:", chrome.runtime.lastError);
                        if ((_a = chrome.runtime.lastError.message) === null || _a === void 0 ? void 0 : _a.includes("Extension context invalidated")) {
                            isConnected = false;
                            connectToBackground();
                        }
                        reject(chrome.runtime.lastError);
                        return;
                    }
                    resolve(response);
                });
            }
            catch (error) {
                console.error("Error in sendBackgroundMessage:", error);
                reject(error);
            }
        });
    });
}
// Call init() after all functions are defined
init();


/***/ }),

/***/ "./src/shared/db.ts":
/*!**************************!*\
  !*** ./src/shared/db.ts ***!
  \**************************/
/***/ (function(__unused_webpack_module, exports) {


var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DatabaseError = void 0;
exports.initDatabase = initDatabase;
exports.addHistoryEntry = addHistoryEntry;
exports.getHistoryEntry = getHistoryEntry;
exports.getAllHistoryEntries = getAllHistoryEntries;
exports.clearOldHistoryEntries = clearOldHistoryEntries;
exports.getHistoryEntriesInRange = getHistoryEntriesInRange;
exports.searchHistoryEntries = searchHistoryEntries;
const DB_NAME = "ai_dictionary_plus";
const DB_VERSION = 1;
const HISTORY_STORE = "history";
const SETTINGS_STORE = "settings";
class DatabaseError extends Error {
    constructor(message) {
        super(message);
        this.name = "DatabaseError";
    }
}
exports.DatabaseError = DatabaseError;
function initDatabase() {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(DB_NAME, DB_VERSION);
            request.onerror = () => {
                reject(new DatabaseError("Failed to open database"));
            };
            request.onsuccess = () => {
                resolve(request.result);
            };
            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                // Create history store with indexes
                if (!db.objectStoreNames.contains(HISTORY_STORE)) {
                    const historyStore = db.createObjectStore(HISTORY_STORE, {
                        keyPath: "id",
                    });
                    historyStore.createIndex("timestamp", "timestamp");
                    historyStore.createIndex("text", "text");
                    historyStore.createIndex("pageUrl", "pageUrl");
                }
                // Create settings store
                if (!db.objectStoreNames.contains(SETTINGS_STORE)) {
                    db.createObjectStore(SETTINGS_STORE);
                }
            };
        });
    });
}
// Add a history entry
function addHistoryEntry(entry) {
    return __awaiter(this, void 0, void 0, function* () {
        const db = yield initDatabase();
        return new Promise((resolve, reject) => {
            const transaction = db.transaction(HISTORY_STORE, "readwrite");
            const store = transaction.objectStore(HISTORY_STORE);
            const request = store.add(entry);
            request.onerror = () => {
                reject(new DatabaseError("Failed to add history entry"));
            };
            request.onsuccess = () => {
                resolve();
            };
        });
    });
}
// Get a history entry by ID
function getHistoryEntry(id) {
    return __awaiter(this, void 0, void 0, function* () {
        const db = yield initDatabase();
        return new Promise((resolve, reject) => {
            const transaction = db.transaction(HISTORY_STORE, "readonly");
            const store = transaction.objectStore(HISTORY_STORE);
            const request = store.get(id);
            request.onerror = () => {
                reject(new DatabaseError("Failed to get history entry"));
            };
            request.onsuccess = () => {
                resolve(request.result || null);
            };
        });
    });
}
// Get all history entries
function getAllHistoryEntries() {
    return __awaiter(this, void 0, void 0, function* () {
        const db = yield initDatabase();
        return new Promise((resolve, reject) => {
            const transaction = db.transaction(HISTORY_STORE, "readonly");
            const store = transaction.objectStore(HISTORY_STORE);
            const request = store.getAll();
            request.onerror = () => {
                reject(new DatabaseError("Failed to get history entries"));
            };
            request.onsuccess = () => {
                resolve(request.result);
            };
        });
    });
}
// Clear history entries older than the specified date
function clearOldHistoryEntries(cutoffTime) {
    return __awaiter(this, void 0, void 0, function* () {
        const db = yield initDatabase();
        return new Promise((resolve, reject) => {
            const transaction = db.transaction(HISTORY_STORE, "readwrite");
            const store = transaction.objectStore(HISTORY_STORE);
            const index = store.index("timestamp");
            // Use a cursor to iterate through old entries
            const range = IDBKeyRange.upperBound(cutoffTime);
            const request = index.openCursor(range);
            request.onerror = () => {
                reject(new DatabaseError("Failed to clear old history entries"));
            };
            request.onsuccess = (event) => {
                const cursor = event.target.result;
                if (cursor) {
                    store.delete(cursor.primaryKey);
                    cursor.continue();
                }
                else {
                    resolve();
                }
            };
        });
    });
}
// Get history entries within a date range
function getHistoryEntriesInRange(startTime, endTime) {
    return __awaiter(this, void 0, void 0, function* () {
        const db = yield initDatabase();
        return new Promise((resolve, reject) => {
            const transaction = db.transaction(HISTORY_STORE, "readonly");
            const store = transaction.objectStore(HISTORY_STORE);
            const index = store.index("timestamp");
            const range = IDBKeyRange.bound(startTime, endTime);
            const request = index.getAll(range);
            request.onerror = () => {
                reject(new DatabaseError("Failed to get history entries in range"));
            };
            request.onsuccess = () => {
                resolve(request.result);
            };
        });
    });
}
// Search history entries by text
function searchHistoryEntries(searchText) {
    return __awaiter(this, void 0, void 0, function* () {
        const db = yield initDatabase();
        return new Promise((resolve, reject) => {
            const transaction = db.transaction(HISTORY_STORE, "readonly");
            const store = transaction.objectStore(HISTORY_STORE);
            const request = store.getAll();
            request.onerror = () => {
                reject(new DatabaseError("Failed to search history entries"));
            };
            request.onsuccess = () => {
                const entries = request.result;
                const searchLower = searchText.toLowerCase();
                const results = entries.filter((entry) => entry.text.toLowerCase().includes(searchLower) ||
                    entry.explanation.toLowerCase().includes(searchLower));
                resolve(results);
            };
        });
    });
}


/***/ }),

/***/ "./src/shared/types.ts":
/*!*****************************!*\
  !*** ./src/shared/types.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports) => {


// Type definitions for the extension
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MessageType = exports.MediaType = exports.DEFAULT_SETTINGS = void 0;
// Default settings
exports.DEFAULT_SETTINGS = {
    apiKey: "",
    perplexityApiKey: "",
    theme: "auto",
    maxTokens: 2000,
    cacheEnabled: true,
    cacheExpiry: 24,
    webSearchEnabled: true,
    keyboardShortcut: {
        key: "E",
        ctrlKey: false,
        shiftKey: true,
        altKey: false,
        metaKey: true, // Cmd key on Mac
    },
    multimodalEnabled: true,
    historyRetention: 7, // Default to 7 days
};
// Media types supported by the extension
var MediaType;
(function (MediaType) {
    MediaType["TEXT"] = "text";
    MediaType["IMAGE"] = "image";
    MediaType["DOCUMENT"] = "document";
    MediaType["AUDIO"] = "audio";
    MediaType["VIDEO"] = "video";
})(MediaType || (exports.MediaType = MediaType = {}));
// Message types for communication between components
var MessageType;
(function (MessageType) {
    MessageType["EXPLAIN_TEXT"] = "EXPLAIN_TEXT";
    MessageType["EXPLANATION_RESULT"] = "EXPLANATION_RESULT";
    MessageType["FOLLOW_UP_QUESTION"] = "FOLLOW_UP_QUESTION";
    MessageType["WEB_SEARCH"] = "WEB_SEARCH";
    MessageType["WEB_SEARCH_RESULT"] = "WEB_SEARCH_RESULT";
    MessageType["OPEN_CHAT"] = "OPEN_CHAT";
    MessageType["GET_SETTINGS"] = "GET_SETTINGS";
    MessageType["SAVE_SETTINGS"] = "SAVE_SETTINGS";
    MessageType["SETTINGS_UPDATED"] = "SETTINGS_UPDATED";
    MessageType["ERROR"] = "ERROR";
    // New message types for multimedia
    MessageType["EXPLAIN_MEDIA"] = "EXPLAIN_MEDIA";
    MessageType["MEDIA_EXPLANATION_RESULT"] = "MEDIA_EXPLANATION_RESULT";
    // New message type for multimodal content (text + media combined)
    MessageType["EXPLAIN_MULTIMODAL"] = "EXPLAIN_MULTIMODAL";
})(MessageType || (exports.MessageType = MessageType = {}));


/***/ }),

/***/ "./src/shared/utils.ts":
/*!*****************************!*\
  !*** ./src/shared/utils.ts ***!
  \*****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isValidText = exports.generateCacheKey = exports.clearExpiredCache = exports.getCacheItem = exports.setCacheItem = exports.cleanupHistoryEntries = exports.getHistoryLogEntry = exports.addHistoryLogEntry = exports.getHistoryLog = exports.HISTORY_LOG_KEY = exports.saveSettings = exports.getSettings = exports.getTheme = exports.getSystemTheme = void 0;
exports.debounce = debounce;
/// <reference types="chrome" />
const types_1 = __webpack_require__(/*! ./types */ "./src/shared/types.ts");
const db_1 = __webpack_require__(/*! ./db */ "./src/shared/db.ts");
// Get current system theme (light or dark)
const getSystemTheme = () => {
    return window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches
        ? "dark"
        : "light";
};
exports.getSystemTheme = getSystemTheme;
// Determine theme based on settings
const getTheme = (settings) => {
    if (settings.theme === "auto") {
        return (0, exports.getSystemTheme)();
    }
    return settings.theme;
};
exports.getTheme = getTheme;
// Get settings from storage
const getSettings = () => __awaiter(void 0, void 0, void 0, function* () {
    return new Promise((resolve) => {
        chrome.storage.sync.get("settings", (result) => {
            // If no settings found, use defaults
            if (!result.settings) {
                resolve(Object.assign({}, types_1.DEFAULT_SETTINGS));
                return;
            }
            // Merge saved settings with defaults to ensure all properties exist
            const mergedSettings = Object.assign(Object.assign(Object.assign({}, types_1.DEFAULT_SETTINGS), result.settings), { 
                // Handle nested objects like keyboardShortcut
                keyboardShortcut: Object.assign(Object.assign({}, types_1.DEFAULT_SETTINGS.keyboardShortcut), (result.settings.keyboardShortcut || {})) });
            resolve(mergedSettings);
        });
    });
});
exports.getSettings = getSettings;
// Save settings to storage
const saveSettings = (settings) => __awaiter(void 0, void 0, void 0, function* () {
    return new Promise((resolve) => {
        chrome.storage.sync.set({ settings }, () => {
            resolve();
        });
    });
});
exports.saveSettings = saveSettings;
// History log functions
exports.HISTORY_LOG_KEY = "explanation_history";
// Get the history log
const getHistoryLog = () => __awaiter(void 0, void 0, void 0, function* () {
    return new Promise((resolve) => {
        chrome.storage.local.get(exports.HISTORY_LOG_KEY, (result) => {
            const historyLog = result[exports.HISTORY_LOG_KEY];
            if (!historyLog) {
                // Initialize empty history log if it doesn't exist
                const emptyLog = {
                    entries: [],
                    lastUpdated: Date.now(),
                };
                resolve(emptyLog);
            }
            else {
                resolve(historyLog);
            }
        });
    });
});
exports.getHistoryLog = getHistoryLog;
// Add an entry to the history log
const addHistoryLogEntry = (entry) => __awaiter(void 0, void 0, void 0, function* () {
    // Generate a unique ID
    const id = `hist_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    // Create the full entry
    const fullEntry = Object.assign(Object.assign({}, entry), { id, timestamp: Date.now() });
    // Add to IndexedDB
    yield (0, db_1.addHistoryEntry)(fullEntry);
    return id;
});
exports.addHistoryLogEntry = addHistoryLogEntry;
// Get a history log entry by ID
const getHistoryLogEntry = (id) => __awaiter(void 0, void 0, void 0, function* () {
    return (0, db_1.getHistoryEntry)(id);
});
exports.getHistoryLogEntry = getHistoryLogEntry;
// Clear entries based on retention settings
const cleanupHistoryEntries = (settings) => __awaiter(void 0, void 0, void 0, function* () {
    // If retention is set to 'forever', don't clean up
    if (settings.historyRetention === "forever") {
        return;
    }
    // Calculate cutoff time based on retention days
    const cutoffTime = Date.now() - settings.historyRetention * 24 * 60 * 60 * 1000;
    // Clear old entries
    yield (0, db_1.clearOldHistoryEntries)(cutoffTime);
});
exports.cleanupHistoryEntries = cleanupHistoryEntries;
// Set an item in the cache with history log reference
const setCacheItem = (key, data, expiryHours, historyLogId) => __awaiter(void 0, void 0, void 0, function* () {
    const cacheItem = {
        data,
        timestamp: Date.now() + expiryHours * 60 * 60 * 1000,
        historyLogId,
    };
    yield chrome.storage.local.set({ [key]: cacheItem });
});
exports.setCacheItem = setCacheItem;
// Get an item from the cache and its history log entry if available
const getCacheItem = (key) => __awaiter(void 0, void 0, void 0, function* () {
    return new Promise((resolve) => {
        chrome.storage.local.get(key, (result) => __awaiter(void 0, void 0, void 0, function* () {
            const cacheItem = result[key];
            // If no cache or expired
            if (!cacheItem || Date.now() > cacheItem.timestamp) {
                resolve({ data: null, historyEntry: null });
                return;
            }
            // Get history entry if available
            let historyEntry = null;
            if (cacheItem.historyLogId) {
                historyEntry = yield (0, exports.getHistoryLogEntry)(cacheItem.historyLogId);
            }
            resolve({ data: cacheItem.data, historyEntry });
        }));
    });
});
exports.getCacheItem = getCacheItem;
// Clear expired cache items
const clearExpiredCache = () => __awaiter(void 0, void 0, void 0, function* () {
    const allCache = (yield chrome.storage.local.get(null));
    const now = Date.now();
    const keysToRemove = [];
    for (const [key, value] of Object.entries(allCache)) {
        const cacheValue = value;
        if (key.startsWith("cache_") &&
            cacheValue.timestamp &&
            cacheValue.timestamp < now) {
            keysToRemove.push(key);
        }
    }
    if (keysToRemove.length > 0) {
        yield chrome.storage.local.remove(keysToRemove);
    }
});
exports.clearExpiredCache = clearExpiredCache;
// Generate a cache key from text
const generateCacheKey = (text) => {
    // Simple hash function for strings
    let hash = 0;
    if (text.length === 0)
        return "cache_empty";
    for (let i = 0; i < text.length; i++) {
        const char = text.charCodeAt(i);
        hash = (hash << 5) - hash + char;
        hash = hash & hash; // Convert to 32bit integer
    }
    return `cache_${hash}`;
};
exports.generateCacheKey = generateCacheKey;
// Debounce function to prevent too many API calls
function debounce(func, waitFor) {
    let timeout = null;
    return function (...args) {
        if (timeout !== null) {
            clearTimeout(timeout);
        }
        timeout = setTimeout(() => func(...args), waitFor);
    };
}
// Function to check if the text is valid for an explanation
const isValidText = (text) => {
    if (!text)
        return false;
    text = text.trim();
    return text.length > 0 && text.length <= 1000; // Arbitrary limit to prevent large requests
};
exports.isValidText = isValidText;


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/content/index.ts");
/******/ 	
/******/ })()
;
//# sourceMappingURL=content.js.map