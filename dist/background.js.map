{"version":3,"file":"background.js","mappings":";;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACrjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AChLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC5LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AEvBA;AACA;AACA;AACA","sources":["webpack://ai-dictionary-plus/./src/background/index.ts","webpack://ai-dictionary-plus/./src/shared/db.ts","webpack://ai-dictionary-plus/./src/shared/types.ts","webpack://ai-dictionary-plus/./src/shared/utils.ts","webpack://ai-dictionary-plus/webpack/bootstrap","webpack://ai-dictionary-plus/webpack/before-startup","webpack://ai-dictionary-plus/webpack/startup","webpack://ai-dictionary-plus/webpack/after-startup"],"sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/// <reference types=\"chrome\" />\nconst utils_1 = require(\"../shared/utils\");\nconst types_1 = require(\"../shared/types\");\nconst db_1 = require(\"../shared/db\");\n// Initialize context menu\nchrome.runtime.onInstalled.addListener(() => {\n    // Clear any existing context menu items first\n    chrome.contextMenus.removeAll(() => {\n        // Create our context menu items\n        chrome.contextMenus.create({\n            id: \"explainText\",\n            title: \"Explain with AI Dictionary+\",\n            contexts: [\"selection\"],\n        });\n        // Add context menu items for media elements\n        chrome.contextMenus.create({\n            id: \"explainImage\",\n            title: \"Explain this image\",\n            contexts: [\"image\"],\n        });\n        chrome.contextMenus.create({\n            id: \"explainVideo\",\n            title: \"Explain this video\",\n            contexts: [\"video\"],\n        });\n        chrome.contextMenus.create({\n            id: \"explainAudio\",\n            title: \"Explain this audio\",\n            contexts: [\"audio\"],\n        });\n        // For documents (links to PDFs, etc.)\n        chrome.contextMenus.create({\n            id: \"explainDocument\",\n            title: \"Explain this document\",\n            contexts: [\"link\"],\n            targetUrlPatterns: [\"*.pdf\", \"*.doc\", \"*.docx\", \"*.txt\"],\n        });\n    });\n    // Clear expired cache items on startup\n    (0, utils_1.clearExpiredCache)();\n});\n// Keep service worker alive\nlet keepAliveInterval;\nfunction startKeepAlive() {\n    // Clear any existing interval\n    if (keepAliveInterval) {\n        clearInterval(keepAliveInterval);\n    }\n    // Ping every 20 seconds to keep the service worker alive\n    keepAliveInterval = setInterval(() => {\n        console.log(\"Service worker ping\");\n    }, 20000);\n}\nfunction stopKeepAlive() {\n    if (keepAliveInterval) {\n        clearInterval(keepAliveInterval);\n    }\n}\n// Start keep-alive when service worker starts\nstartKeepAlive();\n// Handle service worker lifecycle\nchrome.runtime.onSuspend.addListener(() => {\n    console.log(\"Service worker suspending\");\n    stopKeepAlive();\n});\nchrome.runtime.onConnect.addListener((port) => {\n    console.log(\"Port connected:\", port.name);\n    port.onDisconnect.addListener(() => {\n        console.log(\"Port disconnected:\", port.name);\n        if (chrome.runtime.lastError) {\n            console.error(\"Port error:\", chrome.runtime.lastError);\n        }\n    });\n});\n// Handle context menu clicks\nchrome.contextMenus.onClicked.addListener((info, tab) => {\n    console.log(\"Context menu clicked:\", info, tab);\n    if (info.menuItemId === \"explainText\" && info.selectionText && (tab === null || tab === void 0 ? void 0 : tab.id)) {\n        console.log(\"Sending message to tab\", tab.id, \"with text:\", info.selectionText);\n        // Send a message to the content script to show the tooltip\n        try {\n            chrome.tabs.sendMessage(tab.id, {\n                type: types_1.MessageType.EXPLAIN_TEXT,\n                payload: {\n                    text: info.selectionText,\n                },\n            }, (response) => {\n                console.log(\"Response from content script:\", response);\n                if (chrome.runtime.lastError) {\n                    console.error(\"Error sending message to content script:\", chrome.runtime.lastError);\n                }\n            });\n        }\n        catch (error) {\n            console.error(\"Error in context menu handler:\", error);\n        }\n    }\n    else if (info.menuItemId === \"explainImage\" && info.srcUrl && (tab === null || tab === void 0 ? void 0 : tab.id)) {\n        // Handle image explanation request\n        try {\n            chrome.tabs.sendMessage(tab.id, {\n                type: \"CONTEXT_MENU_CLICKED\",\n                payload: {\n                    mediaType: types_1.MediaType.IMAGE,\n                    mediaUrl: info.srcUrl,\n                    pageUrl: info.pageUrl,\n                },\n            }, (response) => {\n                console.log(\"Response from content script for image:\", response);\n                if (chrome.runtime.lastError) {\n                    console.error(\"Error sending message to content script:\", chrome.runtime.lastError);\n                }\n            });\n        }\n        catch (error) {\n            console.error(\"Error in image context menu handler:\", error);\n        }\n    }\n    else if (info.menuItemId === \"explainVideo\" && info.srcUrl && (tab === null || tab === void 0 ? void 0 : tab.id)) {\n        // Handle video explanation request\n        try {\n            chrome.tabs.sendMessage(tab.id, {\n                type: \"CONTEXT_MENU_CLICKED\",\n                payload: {\n                    mediaType: types_1.MediaType.VIDEO,\n                    mediaUrl: info.srcUrl,\n                    pageUrl: info.pageUrl,\n                },\n            }, (response) => {\n                console.log(\"Response from content script for video:\", response);\n                if (chrome.runtime.lastError) {\n                    console.error(\"Error sending message to content script:\", chrome.runtime.lastError);\n                }\n            });\n        }\n        catch (error) {\n            console.error(\"Error in video context menu handler:\", error);\n        }\n    }\n    else if (info.menuItemId === \"explainAudio\" && info.srcUrl && (tab === null || tab === void 0 ? void 0 : tab.id)) {\n        // Handle audio explanation request\n        try {\n            chrome.tabs.sendMessage(tab.id, {\n                type: \"CONTEXT_MENU_CLICKED\",\n                payload: {\n                    mediaType: types_1.MediaType.AUDIO,\n                    mediaUrl: info.srcUrl,\n                    pageUrl: info.pageUrl,\n                },\n            }, (response) => {\n                console.log(\"Response from content script for audio:\", response);\n                if (chrome.runtime.lastError) {\n                    console.error(\"Error sending message to content script:\", chrome.runtime.lastError);\n                }\n            });\n        }\n        catch (error) {\n            console.error(\"Error in audio context menu handler:\", error);\n        }\n    }\n    else if (info.menuItemId === \"explainDocument\" && info.linkUrl && (tab === null || tab === void 0 ? void 0 : tab.id)) {\n        // Handle document explanation request\n        try {\n            chrome.tabs.sendMessage(tab.id, {\n                type: \"CONTEXT_MENU_CLICKED\",\n                payload: {\n                    mediaType: types_1.MediaType.DOCUMENT,\n                    mediaUrl: info.linkUrl,\n                    pageUrl: info.pageUrl,\n                },\n            }, (response) => {\n                console.log(\"Response from content script for document:\", response);\n                if (chrome.runtime.lastError) {\n                    console.error(\"Error sending message to content script:\", chrome.runtime.lastError);\n                }\n            });\n        }\n        catch (error) {\n            console.error(\"Error in document context menu handler:\", error);\n        }\n    }\n});\n// Message listener with error handling and reconnection logic\nchrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n    var _a;\n    console.log(\"Background received message:\", message.type);\n    // Get the tab ID if available\n    const tabId = (_a = sender.tab) === null || _a === void 0 ? void 0 : _a.id;\n    // Handle potential disconnections\n    const handleError = (error) => {\n        var _a, _b;\n        console.error(\"Error in message handler:\", error);\n        // Try to reconnect if context was invalidated\n        if ((_a = error.message) === null || _a === void 0 ? void 0 : _a.includes(\"Extension context invalidated\")) {\n            console.log(\"Attempting to reconnect...\");\n            startKeepAlive();\n        }\n        // Send error response\n        sendResponse({\n            error: error instanceof Error ? error.message : String(error),\n            explanation: \"\",\n            originalText: ((_b = message.payload) === null || _b === void 0 ? void 0 : _b.text) || \"\",\n            conversationHistory: [],\n        });\n    };\n    try {\n        switch (message.type) {\n            case types_1.MessageType.EXPLAIN_TEXT:\n                handleExplainText(message.payload, tabId)\n                    .then((result) => {\n                    sendResponse(result);\n                })\n                    .catch(handleError);\n                break;\n            case types_1.MessageType.FOLLOW_UP_QUESTION:\n                console.log(\"Background handling FOLLOW_UP_QUESTION request\");\n                handleFollowUpQuestion(message.payload, tabId)\n                    .then(sendResponse)\n                    .catch(handleError);\n                break;\n            case types_1.MessageType.WEB_SEARCH:\n                console.log(\"Background handling WEB_SEARCH request\");\n                handleWebSearch(message.payload, tabId)\n                    .then(sendResponse)\n                    .catch(handleError);\n                break;\n            case types_1.MessageType.GET_SETTINGS:\n                console.log(\"Background handling GET_SETTINGS request\");\n                (0, utils_1.getSettings)()\n                    .then((settings) => {\n                    console.log(\"Sending settings:\", settings);\n                    sendResponse(settings);\n                })\n                    .catch(handleError);\n                break;\n            case types_1.MessageType.SAVE_SETTINGS:\n                console.log(\"Background handling SAVE_SETTINGS request\");\n                (0, utils_1.saveSettings)(message.payload)\n                    .then(() => {\n                    console.log(\"Settings saved, broadcasting update\");\n                    // Broadcast settings update to all tabs\n                    chrome.tabs.query({}, (tabs) => {\n                        tabs.forEach((tab) => {\n                            if (tab.id) {\n                                chrome.tabs.sendMessage(tab.id, {\n                                    type: types_1.MessageType.SETTINGS_UPDATED,\n                                    payload: message.payload,\n                                }, () => {\n                                    // Ignore errors - tab might not have a content script\n                                    if (chrome.runtime.lastError) {\n                                        console.log(\"Error sending settings update:\", chrome.runtime.lastError);\n                                    }\n                                });\n                            }\n                        });\n                    });\n                    sendResponse({ success: true });\n                })\n                    .catch(handleError);\n                break;\n            case types_1.MessageType.EXPLAIN_MEDIA:\n                console.log(\"Background handling EXPLAIN_MEDIA request\");\n                handleMediaExplainRequest(message.payload, sender)\n                    .then((result) => {\n                    console.log(\"Sending media explanation result:\", result);\n                    sendResponse(result);\n                })\n                    .catch(handleError);\n                break;\n            case types_1.MessageType.EXPLAIN_MULTIMODAL:\n                handleMultimodalRequest(message.payload, sender)\n                    .then((result) => {\n                    sendResponse(result);\n                })\n                    .catch(handleError);\n                break;\n            default:\n                console.log(\"Unknown message type:\", message.type);\n                break;\n        }\n    }\n    catch (error) {\n        handleError(error);\n    }\n    // Return true to indicate async response\n    return true;\n});\n// Handle explain text requests\nfunction handleExplainText(request, tabId) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            const settings = yield (0, utils_1.getSettings)();\n            if (!settings.apiKey) {\n                return {\n                    explanation: \"Please set your API key in the extension options\",\n                    originalText: request.text,\n                    error: \"No API key\",\n                    conversationHistory: [],\n                };\n            }\n            // Check cache if enabled\n            if (settings.cacheEnabled && !request.skipCache) {\n                const cacheKey = (0, utils_1.generateCacheKey)(request.text);\n                const { data: cachedResult, historyEntry } = yield (0, utils_1.getCacheItem)(cacheKey);\n                if (cachedResult) {\n                    // If we have a history entry, use its conversation history\n                    if (historyEntry) {\n                        cachedResult.conversationHistory = historyEntry.conversationHistory;\n                    }\n                    return cachedResult;\n                }\n            }\n            // Generate enhanced conversation history with system prompts\n            const enhancedConversationHistory = [\n                // System prompt with instructions\n                {\n                    role: \"system\",\n                    content: \"You are AI Dictionary+, a helpful AI assistant integrated into a browser extension. \" +\n                        \"Your purpose is to explain concepts, answer questions, and engage in helpful conversation. \" +\n                        \"You have access to the user's current context and can explain technical terms, concepts, and provide detailed information on a wide range of topics. \" +\n                        \"Always be thorough in your explanations, providing detailed context and real-world examples where applicable. \" +\n                        \"IMPORTANT: Ignore any CSS styling information in the context unless the user is specifically asking about CSS. \" +\n                        \"Focus on explaining the core concept, not the styling or formatting of the webpage. \" +\n                        \"When explaining technical terms, provide clear definitions, examples of use, and relevant context.\",\n                },\n                // Add context about what the user is looking at\n                {\n                    role: \"system\",\n                    content: `The user has selected this text to be explained: \"${request.text}\". ` +\n                        (request.contextText\n                            ? `Additional context surrounding the selection (which may include CSS that should be ignored unless directly relevant): ${request.contextText}`\n                            : \"No additional context is available.\"),\n                },\n                // User question\n                {\n                    role: \"user\",\n                    content: `Explain this clearly and concisely: \"${request.text}\"`,\n                },\n            ];\n            // Call Gemini API with enhanced context\n            const explanation = yield callGeminiAPI(enhancedConversationHistory, settings);\n            // Create result - only include the actual conversation in the history (not system messages)\n            // This prevents UI confusion with system messages appearing in the chat\n            const resultConversationHistory = [\n                {\n                    role: \"user\",\n                    content: `Explain this clearly and concisely: \"${request.text}\"`,\n                },\n                {\n                    role: \"assistant\",\n                    content: explanation,\n                },\n            ];\n            // Create result\n            const result = {\n                explanation,\n                originalText: request.text,\n                conversationHistory: resultConversationHistory,\n            };\n            // Add to history log\n            const historyLogId = yield (0, utils_1.addHistoryLogEntry)({\n                text: request.text,\n                contextText: request.contextText,\n                explanation,\n                conversationHistory: resultConversationHistory,\n                pageUrl: request.pageUrl,\n            });\n            // Cache result if enabled\n            if (settings.cacheEnabled) {\n                const cacheKey = (0, utils_1.generateCacheKey)(request.text);\n                yield (0, utils_1.setCacheItem)(cacheKey, result, settings.cacheExpiry, historyLogId);\n            }\n            // Clean up old history entries based on retention settings\n            (0, utils_1.cleanupHistoryEntries)(settings).catch(console.error);\n            return result;\n        }\n        catch (error) {\n            console.error(\"Error explaining text:\", error);\n            return {\n                explanation: \"An error occurred while getting the explanation.\",\n                originalText: request.text,\n                error: error instanceof Error ? error.message : String(error),\n                conversationHistory: [],\n            };\n        }\n    });\n}\n// Handle follow-up questions\nfunction handleFollowUpQuestion(request, tabId) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            const settings = yield (0, utils_1.getSettings)();\n            if (!settings.apiKey) {\n                return {\n                    explanation: \"Please set your API key in the extension options\",\n                    originalText: request.originalText,\n                    error: \"No API key\",\n                    conversationHistory: [],\n                };\n            }\n            // Enhanced conversation history with system prompts for better context\n            const enhancedConversationHistory = [];\n            // Add system prompt about AI Dictionary+ capabilities\n            enhancedConversationHistory.push({\n                role: \"system\",\n                content: \"You are AI Dictionary+, a helpful AI assistant integrated into a browser extension. \" +\n                    \"Your purpose is to explain concepts, answer questions, and engage in helpful conversation. \" +\n                    \"You have access to the user's current context and can explain technical terms, concepts, and provide detailed information on a wide range of topics. \" +\n                    \"Always be thorough in your explanations, providing detailed context and real-world examples where applicable. \" +\n                    \"IMPORTANT: Ignore any CSS styling information in the context unless the user is specifically asking about CSS. \" +\n                    \"Focus on explaining the core concept, not the styling or formatting of the webpage. \" +\n                    \"When explaining technical terms, provide clear definitions, examples of use, and relevant context.\",\n            });\n            // Add context about the content the user is viewing if available\n            if (request.originalText) {\n                enhancedConversationHistory.push({\n                    role: \"system\",\n                    content: `The user is currently looking at content related to: \"${request.originalText}\". Tailor your responses to be relevant to this context when appropriate, but ignore CSS styling information unless specifically asked about it.`,\n                });\n            }\n            // Add existing conversation history\n            enhancedConversationHistory.push(...request.conversationHistory);\n            // Add current user question\n            enhancedConversationHistory.push({\n                role: \"user\",\n                content: request.question,\n            });\n            // Use the user's configured token limit (no arbitrary doubling)\n            const explanation = yield callGeminiAPI(enhancedConversationHistory, settings);\n            // Create result - only include the actual conversation in the history (not system messages)\n            // This prevents UI confusion with system messages appearing in the chat\n            const resultConversationHistory = [\n                ...request.conversationHistory,\n                { role: \"user\", content: request.question },\n                { role: \"assistant\", content: explanation },\n            ];\n            const result = {\n                explanation,\n                originalText: request.originalText,\n                conversationHistory: resultConversationHistory,\n            };\n            // Find and update the history entry for this conversation\n            const historyEntries = yield (0, db_1.getAllHistoryEntries)();\n            const historyEntry = historyEntries.find((entry) => entry.text === request.originalText);\n            if (historyEntry) {\n                // Update the conversation history\n                const updatedEntry = Object.assign(Object.assign({}, historyEntry), { conversationHistory: resultConversationHistory });\n                // Update the entry in the database\n                yield (0, db_1.addHistoryEntry)(updatedEntry);\n            }\n            return result;\n        }\n        catch (error) {\n            console.error(\"Error with follow-up question:\", error);\n            return {\n                explanation: \"An error occurred while getting the explanation.\",\n                originalText: request.originalText,\n                error: error instanceof Error ? error.message : String(error),\n                conversationHistory: request.conversationHistory,\n            };\n        }\n    });\n}\n// Call Gemini API\nfunction callGeminiAPI(conversationHistory, settings) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var _a, _b, _c;\n        const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${settings.apiKey}`;\n        // Format the conversation for Gemini\n        const contents = conversationHistory.map((message) => {\n            // Map roles from our app format to Gemini API format\n            let apiRole = \"user\";\n            if (message.role === \"assistant\") {\n                apiRole = \"model\";\n            }\n            else if (message.role === \"system\") {\n                // For system messages, we'll use \"user\" role but add a prefix to indicate system instructions\n                return {\n                    parts: [\n                        {\n                            text: \"[SYSTEM INSTRUCTION]\\n\" + message.content,\n                        },\n                    ],\n                    role: \"user\",\n                };\n            }\n            return {\n                parts: [\n                    {\n                        text: message.content,\n                    },\n                ],\n                role: apiRole,\n            };\n        });\n        // Additional system instructions to include in the prompt\n        const enhancedInstructions = {\n            safetySettings: [\n                {\n                    category: \"HARM_CATEGORY_HARASSMENT\",\n                    threshold: \"BLOCK_MEDIUM_AND_ABOVE\",\n                },\n                {\n                    category: \"HARM_CATEGORY_HATE_SPEECH\",\n                    threshold: \"BLOCK_MEDIUM_AND_ABOVE\",\n                },\n                {\n                    category: \"HARM_CATEGORY_SEXUALLY_EXPLICIT\",\n                    threshold: \"BLOCK_MEDIUM_AND_ABOVE\",\n                },\n                {\n                    category: \"HARM_CATEGORY_DANGEROUS_CONTENT\",\n                    threshold: \"BLOCK_MEDIUM_AND_ABOVE\",\n                },\n            ],\n            generationConfig: {\n                maxOutputTokens: settings.maxTokens,\n                temperature: 0.2,\n                topP: 0.95,\n                topK: 40,\n            },\n        };\n        const payload = Object.assign({ contents }, enhancedInstructions);\n        console.log(\"Sending payload to Gemini:\", JSON.stringify(payload));\n        const response = yield fetch(url, {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n            },\n            body: JSON.stringify(payload),\n        });\n        if (!response.ok) {\n            const errorText = yield response.text();\n            throw new Error(`Gemini API error: ${response.status} - ${errorText}`);\n        }\n        const data = yield response.json();\n        // Extract text from response\n        if (data.candidates &&\n            ((_b = (_a = data.candidates[0]) === null || _a === void 0 ? void 0 : _a.content) === null || _b === void 0 ? void 0 : _b.parts) &&\n            ((_c = data.candidates[0].content.parts[0]) === null || _c === void 0 ? void 0 : _c.text)) {\n            return data.candidates[0].content.parts[0].text;\n        }\n        throw new Error(\"Unexpected API response format\");\n    });\n}\n// Handle web search requests\nfunction handleWebSearch(request, tabId) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            const settings = yield (0, utils_1.getSettings)();\n            if (!settings.perplexityApiKey) {\n                return {\n                    explanation: request.originalExplanation,\n                    originalText: request.text,\n                    error: \"Please set your Perplexity API key in the extension options\",\n                    conversationHistory: [],\n                    webSearched: false,\n                };\n            }\n            // Call Perplexity API to get enhanced explanation and citations\n            const { explanation, citations } = yield callPerplexityAPI(request.text, request.originalExplanation, settings);\n            console.log(\"Web search result:\", { explanation, citations });\n            // Create result\n            const result = {\n                explanation,\n                originalText: request.text,\n                conversationHistory: [\n                    {\n                        role: \"user\",\n                        content: `Please explain: \"${request.text}\"`,\n                    },\n                    {\n                        role: \"assistant\",\n                        content: explanation,\n                    },\n                ],\n                webSearched: true,\n                citations,\n            };\n            return result;\n        }\n        catch (error) {\n            console.error(\"Error in web search:\", error);\n            return {\n                explanation: request.originalExplanation,\n                originalText: request.text,\n                error: error instanceof Error ? error.message : String(error),\n                conversationHistory: [],\n                webSearched: false,\n            };\n        }\n    });\n}\n// Call Perplexity API with the sonar model\nfunction callPerplexityAPI(query, originalExplanation, settings) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var _a, _b;\n        const url = \"https://api.perplexity.ai/chat/completions\";\n        const systemPrompt = `You are an AI assistant that provides enhanced explanations by searching the web for accurate and up-to-date information. You are given a query and an initial explanation. Your task is to:\n1. Enhance the explanation with additional facts, context, and details from the web.\n2. Maintain a clear, educational tone.\n3. Add citation references like [1], [2], etc. at relevant points in your response.\n4. Format your response using Markdown for better readability.\n5. Keep your response concise and focused on the topic.`;\n        const payload = {\n            model: \"sonar\",\n            messages: [\n                {\n                    role: \"system\",\n                    content: systemPrompt,\n                },\n                {\n                    role: \"user\",\n                    content: `I need an enhanced explanation of: \"${query}\"\\n\\nHere's the initial explanation to improve upon:\\n${originalExplanation}\\n\\nPlease enhance this with web search results and add citations.`,\n                },\n            ],\n            max_tokens: settings.maxTokens,\n            temperature: 0.2,\n        };\n        const response = yield fetch(url, {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n                Authorization: `Bearer ${settings.perplexityApiKey}`,\n            },\n            body: JSON.stringify(payload),\n        });\n        if (!response.ok) {\n            const errorText = yield response.text();\n            throw new Error(`Perplexity API error: ${response.status} - ${errorText}`);\n        }\n        const data = yield response.json();\n        console.log(\"Perplexity API response:\", data);\n        // Extract response text\n        if (data.choices && ((_b = (_a = data.choices[0]) === null || _a === void 0 ? void 0 : _a.message) === null || _b === void 0 ? void 0 : _b.content)) {\n            const explanation = data.choices[0].message.content;\n            // Extract citations directly from the API response\n            const citations = data.citations || [];\n            return { explanation, citations };\n        }\n        throw new Error(\"Unexpected API response format from Perplexity\");\n    });\n}\n// Function to upload video to Gemini File API and get a file URI\nfunction uploadVideoToGeminiAPI(videoUrl, apiKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n        console.log(\"Uploading video to Gemini File API:\", videoUrl);\n        try {\n            // Fetch the video data\n            const response = yield fetch(videoUrl);\n            if (!response.ok) {\n                throw new Error(`Failed to fetch video: ${response.status} ${response.statusText}`);\n            }\n            // Get the video data as blob\n            const videoBlob = yield response.blob();\n            // Get the content type\n            const mimeType = response.headers.get(\"content-type\") || \"video/mp4\";\n            // Create form data for upload\n            const formData = new FormData();\n            formData.append(\"file\", videoBlob, \"video.mp4\");\n            // Upload to Gemini Files API\n            const uploadUrl = `https://generativelanguage.googleapis.com/upload/v1beta/files?key=${apiKey}`;\n            // Initial resumable upload request\n            const initResponse = yield fetch(uploadUrl, {\n                method: \"POST\",\n                headers: {\n                    \"X-Goog-Upload-Protocol\": \"resumable\",\n                    \"X-Goog-Upload-Command\": \"start\",\n                    \"X-Goog-Upload-Header-Content-Length\": videoBlob.size.toString(),\n                    \"X-Goog-Upload-Header-Content-Type\": mimeType,\n                    \"Content-Type\": \"application/json\",\n                },\n                body: JSON.stringify({\n                    file: {\n                        display_name: \"Uploaded Video\",\n                    },\n                }),\n            });\n            if (!initResponse.ok) {\n                throw new Error(`Failed to initialize upload: ${initResponse.status} ${initResponse.statusText}`);\n            }\n            // Get the upload URL from headers\n            const uploadSessionUrl = initResponse.headers.get(\"X-Goog-Upload-URL\");\n            if (!uploadSessionUrl) {\n                throw new Error(\"Upload URL not found in response headers\");\n            }\n            // Upload the video content\n            const uploadResponse = yield fetch(uploadSessionUrl, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Length\": videoBlob.size.toString(),\n                    \"X-Goog-Upload-Offset\": \"0\",\n                    \"X-Goog-Upload-Command\": \"upload, finalize\",\n                },\n                body: videoBlob,\n            });\n            if (!uploadResponse.ok) {\n                throw new Error(`Failed to upload video content: ${uploadResponse.status} ${uploadResponse.statusText}`);\n            }\n            // Parse the response to get the file URI\n            const fileInfo = yield uploadResponse.json();\n            console.log(\"File upload response:\", JSON.stringify(fileInfo, null, 2));\n            if (!fileInfo.file || !fileInfo.file.uri) {\n                throw new Error(\"File URI not found in upload response\");\n            }\n            // Wait for the file to be processed (if needed)\n            let file = fileInfo.file;\n            let processingAttempts = 0;\n            const maxProcessingAttempts = 5;\n            while (file.state === \"PROCESSING\" &&\n                processingAttempts < maxProcessingAttempts) {\n                processingAttempts++;\n                console.log(`Video still processing, attempt ${processingAttempts}/${maxProcessingAttempts}...`);\n                yield new Promise((resolve) => setTimeout(resolve, 5000)); // Wait 5 seconds\n                // Check file status - Use the full file name as returned by the API\n                // The file.name already contains the full path like \"files/12345\"\n                let fileStatusUrl;\n                if (file.name.startsWith(\"files/\")) {\n                    fileStatusUrl = `https://generativelanguage.googleapis.com/v1beta/${file.name}?key=${apiKey}`;\n                }\n                else {\n                    fileStatusUrl = `https://generativelanguage.googleapis.com/v1beta/files/${file.name}?key=${apiKey}`;\n                }\n                console.log(\"Checking file status at URL:\", fileStatusUrl);\n                try {\n                    const fileResponse = yield fetch(fileStatusUrl);\n                    if (!fileResponse.ok) {\n                        console.error(\"Failed to check file status:\", fileResponse.status, fileResponse.statusText);\n                        // Don't throw an error, just try the alternative URL format if this is the first failure\n                        if (processingAttempts === 1 && fileStatusUrl.includes(\"/files/\")) {\n                            // Try alternative URL format\n                            file.name = file.name.replace(\"files/\", \"\");\n                            continue; // Skip to next iteration with new file name\n                        }\n                        throw new Error(`Failed to check file status: ${fileResponse.status} ${fileResponse.statusText}`);\n                    }\n                    const fileStatusData = yield fileResponse.json();\n                    console.log(\"File status response:\", JSON.stringify(fileStatusData, null, 2));\n                    file = fileStatusData.file || fileStatusData;\n                }\n                catch (error) {\n                    console.error(\"Error checking file status:\", error);\n                    // If this is not the last attempt, continue trying\n                    if (processingAttempts < maxProcessingAttempts) {\n                        continue;\n                    }\n                    throw error;\n                }\n            }\n            if (processingAttempts >= maxProcessingAttempts &&\n                file.state === \"PROCESSING\") {\n                throw new Error(\"Video processing timed out after multiple attempts\");\n            }\n            if (file.state === \"FAILED\") {\n                throw new Error(\"Video processing failed\");\n            }\n            console.log(\"Video uploaded successfully, file URI:\", file.uri);\n            return {\n                name: file.name,\n                file_uri: file.uri,\n            };\n        }\n        catch (error) {\n            console.error(\"Error uploading video to Gemini File API:\", error);\n            // Create a more user-friendly error message based on the specific error\n            let userMessage = \"Failed to process the video. \";\n            if (error instanceof Error) {\n                const errorMessage = error.message;\n                console.error(\"Error details:\", errorMessage);\n                // Add specific error handling based on common failures\n                if (errorMessage.includes(\"Failed to fetch video\")) {\n                    userMessage +=\n                        \"The video URL couldn't be accessed. This may be due to cross-origin restrictions or the video is not publicly accessible.\";\n                }\n                else if (errorMessage.includes(\"Failed to initialize upload\")) {\n                    userMessage +=\n                        \"The Gemini API couldn't start the upload process. Please check your API key and network connection.\";\n                }\n                else if (errorMessage.includes(\"Upload URL not found\")) {\n                    userMessage +=\n                        \"The upload session couldn't be established with the Gemini API. This may be a temporary issue.\";\n                }\n                else if (errorMessage.includes(\"Failed to upload video content\")) {\n                    userMessage +=\n                        \"The video couldn't be uploaded to the Gemini API. This may be due to the file size or network issues.\";\n                }\n                else if (errorMessage.includes(\"File URI not found\")) {\n                    userMessage +=\n                        \"The uploaded file information wasn't returned properly. This is usually a temporary API issue.\";\n                }\n                else if (errorMessage.includes(\"Failed to check file status\")) {\n                    userMessage +=\n                        \"The status of the uploaded video couldn't be verified. The file may have been deleted or may not be accessible.\";\n                }\n                else if (errorMessage.includes(\"Video processing failed\")) {\n                    userMessage +=\n                        \"The Gemini API couldn't process the video. This may be due to an unsupported format or content issues.\";\n                }\n                else {\n                    userMessage += \"An unexpected error occurred: \" + errorMessage;\n                }\n            }\n            else {\n                userMessage += \"An unknown error occurred during video processing.\";\n            }\n            // Throw a new error with the user-friendly message\n            throw new Error(userMessage);\n        }\n    });\n}\n/**\n * Upload an audio file to the Gemini File API\n * This function handles the upload process for audio files similar to videos\n */\nfunction uploadAudioToGeminiAPI(audioUrl) {\n    return __awaiter(this, void 0, void 0, function* () {\n        console.log(\"Uploading audio to Gemini File API:\", audioUrl);\n        try {\n            // Fetch the audio file data from URL\n            const response = yield fetch(audioUrl);\n            if (!response.ok) {\n                throw new Error(`Failed to fetch audio file: ${response.status} ${response.statusText}`);\n            }\n            // Get the audio data as blob\n            const audioBlob = yield response.blob();\n            console.log(\"Audio blob:\", audioBlob);\n            // Get API key for Gemini\n            const settings = yield (0, utils_1.getSettings)();\n            const apiKey = settings.apiKey;\n            if (!apiKey) {\n                throw new Error(\"API key not found in settings\");\n            }\n            // Get the content type\n            const mimeType = response.headers.get(\"content-type\") || \"audio/mpeg\";\n            // Create form data for upload\n            const formData = new FormData();\n            formData.append(\"file\", audioBlob, \"audio.mp3\");\n            // Upload to Gemini Files API - using the same endpoint as video uploads\n            const uploadUrl = `https://generativelanguage.googleapis.com/upload/v1beta/files?key=${apiKey}`;\n            // Initial resumable upload request\n            const initResponse = yield fetch(uploadUrl, {\n                method: \"POST\",\n                headers: {\n                    \"X-Goog-Upload-Protocol\": \"resumable\",\n                    \"X-Goog-Upload-Command\": \"start\",\n                    \"X-Goog-Upload-Header-Content-Length\": audioBlob.size.toString(),\n                    \"X-Goog-Upload-Header-Content-Type\": mimeType,\n                    \"Content-Type\": \"application/json\",\n                },\n                body: JSON.stringify({\n                    file: {\n                        display_name: \"Uploaded Audio\",\n                    },\n                }),\n            });\n            if (!initResponse.ok) {\n                throw new Error(`Failed to initialize upload: ${initResponse.status} ${initResponse.statusText}`);\n            }\n            // Get the upload URL from headers\n            const uploadSessionUrl = initResponse.headers.get(\"X-Goog-Upload-URL\");\n            if (!uploadSessionUrl) {\n                throw new Error(\"Upload URL not found in response headers\");\n            }\n            // Upload the audio content\n            const uploadResponse = yield fetch(uploadSessionUrl, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Length\": audioBlob.size.toString(),\n                    \"X-Goog-Upload-Offset\": \"0\",\n                    \"X-Goog-Upload-Command\": \"upload, finalize\",\n                },\n                body: audioBlob,\n            });\n            if (!uploadResponse.ok) {\n                throw new Error(`Failed to upload audio content: ${uploadResponse.status} ${uploadResponse.statusText}`);\n            }\n            // Parse the response to get the file URI\n            const fileInfo = yield uploadResponse.json();\n            console.log(\"File upload response:\", JSON.stringify(fileInfo, null, 2));\n            if (!fileInfo.file || !fileInfo.file.uri) {\n                throw new Error(\"File URI not found in upload response\");\n            }\n            // Wait for the file to be processed (if needed)\n            let file = fileInfo.file;\n            let processingAttempts = 0;\n            const maxProcessingAttempts = 5;\n            while (file.state === \"PROCESSING\" &&\n                processingAttempts < maxProcessingAttempts) {\n                processingAttempts++;\n                console.log(`Audio still processing, attempt ${processingAttempts}/${maxProcessingAttempts}...`);\n                yield new Promise((resolve) => setTimeout(resolve, 5000)); // Wait 5 seconds\n                // Check file status - Use the full file name as returned by the API\n                // Construct URL differently based on the format of the file.name\n                let fileStatusUrl;\n                if (file.name.startsWith(\"files/\")) {\n                    fileStatusUrl = `https://generativelanguage.googleapis.com/v1beta/${file.name}?key=${apiKey}`;\n                }\n                else {\n                    fileStatusUrl = `https://generativelanguage.googleapis.com/v1beta/files/${file.name}?key=${apiKey}`;\n                }\n                console.log(\"Checking file status at URL:\", fileStatusUrl);\n                try {\n                    const fileResponse = yield fetch(fileStatusUrl);\n                    if (!fileResponse.ok) {\n                        console.error(\"Failed to check file status:\", fileResponse.status, fileResponse.statusText);\n                        // Don't throw an error, just try the alternative URL format if this is the first failure\n                        if (processingAttempts === 1 && fileStatusUrl.includes(\"/files/\")) {\n                            // Try alternative URL format\n                            file.name = file.name.replace(\"files/\", \"\");\n                            continue; // Skip to next iteration with new file name\n                        }\n                        throw new Error(`Failed to check file status: ${fileResponse.status} ${fileResponse.statusText}`);\n                    }\n                    const fileStatusData = yield fileResponse.json();\n                    console.log(\"File status response:\", JSON.stringify(fileStatusData, null, 2));\n                    file = fileStatusData.file || fileStatusData;\n                }\n                catch (error) {\n                    console.error(\"Error checking file status:\", error);\n                    // If this is not the last attempt, continue trying\n                    if (processingAttempts < maxProcessingAttempts) {\n                        continue;\n                    }\n                    throw error;\n                }\n            }\n            if (processingAttempts >= maxProcessingAttempts &&\n                file.state === \"PROCESSING\") {\n                throw new Error(\"Audio processing timed out after multiple attempts\");\n            }\n            if (file.state === \"FAILED\") {\n                throw new Error(\"Audio processing failed\");\n            }\n            console.log(\"Audio uploaded successfully, file URI:\", file.uri);\n            return {\n                name: file.name,\n                file_uri: file.uri,\n            };\n        }\n        catch (error) {\n            console.error(\"Error uploading audio to Gemini File API:\", error);\n            // Create a more user-friendly error message based on the specific error\n            let userMessage = \"Failed to process the audio. \";\n            if (error instanceof Error) {\n                const errorMessage = error.message;\n                console.error(\"Error details:\", errorMessage);\n                // Add specific error handling based on common failures\n                if (errorMessage.includes(\"Failed to fetch audio\")) {\n                    userMessage +=\n                        \"The audio URL couldn't be accessed. This may be due to cross-origin restrictions or the audio is not publicly accessible.\";\n                }\n                else if (errorMessage.includes(\"Failed to initialize upload\")) {\n                    userMessage +=\n                        \"The Gemini API couldn't start the upload process. Please check your API key and network connection.\";\n                }\n                else if (errorMessage.includes(\"Upload URL not found\")) {\n                    userMessage +=\n                        \"The upload session couldn't be established with the Gemini API. This may be a temporary issue.\";\n                }\n                else if (errorMessage.includes(\"Failed to upload audio content\")) {\n                    userMessage +=\n                        \"The audio couldn't be uploaded to the Gemini API. This may be due to the file size or network issues.\";\n                }\n                else if (errorMessage.includes(\"File URI not found\")) {\n                    userMessage +=\n                        \"The uploaded file information wasn't returned properly. This is usually a temporary API issue.\";\n                }\n                else if (errorMessage.includes(\"Failed to check file status\")) {\n                    userMessage +=\n                        \"The status of the uploaded audio couldn't be verified. The file may have been deleted or may not be accessible.\";\n                }\n                else if (errorMessage.includes(\"Audio processing failed\")) {\n                    userMessage +=\n                        \"The Gemini API couldn't process the audio. This may be due to an unsupported format or content issues.\";\n                }\n                else {\n                    userMessage += \"An unexpected error occurred: \" + errorMessage;\n                }\n            }\n            else {\n                userMessage += \"An unknown error occurred during audio processing.\";\n            }\n            // Throw a new error with the user-friendly message\n            throw new Error(userMessage);\n        }\n    });\n}\n// Update handleMediaExplainRequest to support both video and audio uploads\nfunction handleMediaExplainRequest(request, sender) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var _a;\n        try {\n            console.log(\"Handling media explain request:\", request);\n            // Get settings\n            const settings = yield (0, utils_1.getSettings)();\n            // Check if multimodal is enabled\n            if (!settings.multimodalEnabled) {\n                return {\n                    explanation: \"Multimedia content analysis is not enabled. Please enable it in the extension options.\",\n                    error: \"Feature not enabled\",\n                    conversationHistory: [],\n                    originalText: `${request.mediaType} content`,\n                };\n            }\n            // Check if API key is set\n            if (!settings.apiKey) {\n                return {\n                    explanation: \"Please set your API key in the extension options\",\n                    error: \"No API key\",\n                    conversationHistory: [],\n                    originalText: `${request.mediaType} content`,\n                };\n            }\n            // Set tab ID from sender if not provided\n            if (!request.tabId && ((_a = sender.tab) === null || _a === void 0 ? void 0 : _a.id)) {\n                request.tabId = sender.tab.id;\n            }\n            // Check if we are handling a video that needs to be uploaded using File API\n            let fileUri;\n            if (request.mediaType === types_1.MediaType.VIDEO) {\n                console.log(\"Processing video with File API\");\n                try {\n                    // uploadVideoToGeminiAPI now returns an object with file_uri property\n                    const fileResult = yield uploadVideoToGeminiAPI(request.mediaData, settings.apiKey);\n                    fileUri = fileResult.file_uri;\n                    console.log(\"Video uploaded successfully, file_uri:\", fileUri);\n                }\n                catch (error) {\n                    console.error(\"Error uploading video:\", error);\n                    throw new Error(`Video upload failed: ${error instanceof Error ? error.message : String(error)}`);\n                }\n            }\n            // Check if we are handling an audio file that needs to be uploaded using File API\n            else if (request.mediaType === types_1.MediaType.AUDIO) {\n                console.log(\"Processing audio with File API\");\n                try {\n                    // uploadAudioToGeminiAPI returns an object with file_uri property\n                    const fileResult = yield uploadAudioToGeminiAPI(request.mediaData);\n                    fileUri = fileResult.file_uri;\n                    console.log(\"Audio uploaded successfully, file_uri:\", fileUri);\n                }\n                catch (error) {\n                    console.error(\"Error uploading audio:\", error);\n                    throw new Error(`Audio upload failed: ${error instanceof Error ? error.message : String(error)}`);\n                }\n            }\n            // For images and other media types, proceed with regular processing\n            else if (request.mediaType === types_1.MediaType.IMAGE &&\n                request.mediaData.startsWith(\"http\")) {\n                console.log(\"Processing image URL, fetching as base64\");\n                // Fetch image as base64 for URLs\n                try {\n                    request.mediaData = yield fetchImageAsBase64(request.mediaData);\n                }\n                catch (error) {\n                    console.error(\"Error fetching image as base64:\", error);\n                    throw new Error(`Image processing failed: ${error instanceof Error ? error.message : String(error)}`);\n                }\n            }\n            // Create conversation history\n            const conversationHistory = [];\n            // Add system message\n            conversationHistory.push({\n                role: \"system\",\n                content: getSystemPromptForMedia(request.mediaType),\n            });\n            // Add user message with media content\n            const userMessage = {\n                role: \"user\",\n                content: [],\n            };\n            // Create content parts based on media type\n            const contentParts = [];\n            // Add text part with context and instructions\n            let textPrompt = `Please analyze this ${request.mediaType.toLowerCase()}`;\n            // Add timestamp for videos if available\n            if (request.mediaType === types_1.MediaType.VIDEO && request.timestamp) {\n                textPrompt += ` at timestamp ${request.timestamp}`;\n            }\n            // Add context if available\n            if (request.contextText) {\n                textPrompt += `. Context: ${request.contextText}`;\n            }\n            // Add text part\n            contentParts.push({\n                type: \"text\",\n                text: textPrompt,\n            });\n            // Add media part\n            if (request.mediaType === types_1.MediaType.IMAGE &&\n                request.mediaData.startsWith(\"data:\")) {\n                // For images with base64 data\n                contentParts.push({\n                    type: \"image\",\n                    mediaData: request.mediaData,\n                    mimeType: request.mimeType || \"image/jpeg\",\n                });\n            }\n            else if (request.mediaType === types_1.MediaType.VIDEO) {\n                // For videos using file_uri format\n                contentParts.push({\n                    type: \"video\",\n                    file_uri: fileUri, // This should now be a proper file_uri from the File API\n                    mimeType: request.mimeType || \"video/mp4\",\n                });\n            }\n            else if (request.mediaType === types_1.MediaType.AUDIO && fileUri) {\n                // For audio using file_uri format\n                contentParts.push({\n                    type: \"audio\",\n                    file_uri: fileUri, // Use the file_uri from the upload\n                    mimeType: request.mimeType || \"audio/mpeg\",\n                });\n            }\n            else {\n                // For other media types or images with URLs\n                contentParts.push({\n                    type: request.mediaType.toLowerCase(),\n                    mediaData: request.mediaData,\n                    mimeType: request.mimeType ||\n                        getMimeTypeForMedia(request.mediaType, request.mediaData),\n                });\n            }\n            // Set the content parts in the user message\n            userMessage.content = contentParts;\n            conversationHistory.push(userMessage);\n            // Call Gemini API for multimodal content\n            console.log(\"Calling Gemini API with conversation history:\", conversationHistory);\n            const explanation = yield callGeminiMultimodalAPI(conversationHistory, settings);\n            // Add assistant response to conversation history\n            conversationHistory.push({\n                role: \"assistant\",\n                content: explanation,\n            });\n            // Return the result\n            return {\n                explanation,\n                conversationHistory,\n                originalText: `[${request.mediaType.toUpperCase()}] ${request.pageUrl || \"Unknown URL\"}`,\n            };\n        }\n        catch (error) {\n            console.error(\"Error in handleMediaExplainRequest:\", error);\n            return {\n                explanation: \"\",\n                originalText: \"\",\n                error: `${error instanceof Error ? error.message : String(error)}`,\n                conversationHistory: [],\n            };\n        }\n    });\n}\n// Helper function to get system prompt for different media types\nfunction getSystemPromptForMedia(mediaType) {\n    const basePrompt = \"You are AI Dictionary+, a helpful AI assistant that explains content on the web. \";\n    switch (mediaType) {\n        case types_1.MediaType.IMAGE:\n            return (basePrompt +\n                \"Analyze the image and provide a detailed explanation of what it shows. \" +\n                \"Include information about the subject, composition, colors, and any text visible in the image. \" +\n                \"If it's a chart or diagram, explain what it represents. Be concise but thorough.\");\n        case types_1.MediaType.VIDEO:\n            return (basePrompt +\n                \"Analyze the video frame and provide a detailed explanation of what it shows. \" +\n                \"Describe the scene, any visible action, and key elements in the frame. \" +\n                \"If there's text or captions visible, include that in your analysis. Be concise but thorough.\");\n        case types_1.MediaType.AUDIO:\n            return (basePrompt +\n                \"Analyze the audio content and describe what you hear. \" +\n                \"If it's speech, summarize what is being said. If it's music, describe the genre, instruments, and mood. \" +\n                \"Note any distinctive sounds or patterns. Be concise but thorough.\");\n        case types_1.MediaType.DOCUMENT:\n            return (basePrompt +\n                \"Analyze the document and provide a summary of its content. \" +\n                \"Identify the document type, key topics, and main points. \" +\n                \"If there are charts, tables, or images, describe what they show. Be concise but thorough.\");\n        default:\n            return (basePrompt +\n                \"Analyze the content and provide a detailed explanation. Be concise but thorough.\");\n    }\n}\n// Helper function to get MIME type for media\nfunction getMimeTypeForMedia(mediaType, mediaUrl) {\n    var _a;\n    // Default MIME types based on media type\n    const defaultMimeTypes = {\n        [types_1.MediaType.IMAGE]: \"image/jpeg\",\n        [types_1.MediaType.VIDEO]: \"video/mp4\",\n        [types_1.MediaType.AUDIO]: \"audio/mpeg\",\n        [types_1.MediaType.DOCUMENT]: \"application/pdf\",\n        [types_1.MediaType.TEXT]: \"text/plain\",\n    };\n    // Try to determine from URL extension\n    const extension = (_a = mediaUrl.split(\".\").pop()) === null || _a === void 0 ? void 0 : _a.toLowerCase();\n    if (extension) {\n        switch (extension) {\n            // Images\n            case \"jpg\":\n            case \"jpeg\":\n                return \"image/jpeg\";\n            case \"png\":\n                return \"image/png\";\n            case \"gif\":\n                return \"image/gif\";\n            case \"webp\":\n                return \"image/webp\";\n            case \"svg\":\n                return \"image/svg+xml\";\n            // Videos\n            case \"mp4\":\n                return \"video/mp4\";\n            case \"webm\":\n                return \"video/webm\";\n            case \"ogg\":\n                return \"video/ogg\";\n            case \"mov\":\n                return \"video/quicktime\";\n            // Audio\n            case \"mp3\":\n                return \"audio/mpeg\";\n            case \"wav\":\n                return \"audio/wav\";\n            case \"aac\":\n                return \"audio/aac\";\n            case \"flac\":\n                return \"audio/flac\";\n            // Documents\n            case \"pdf\":\n                return \"application/pdf\";\n            case \"doc\":\n            case \"docx\":\n                return \"application/msword\";\n            case \"txt\":\n                return \"text/plain\";\n        }\n    }\n    // Fallback to default MIME type for this media type\n    return defaultMimeTypes[mediaType] || \"application/octet-stream\";\n}\n// New function for calling Gemini API with multimodal content\nfunction callGeminiMultimodalAPI(conversationHistory, settings) {\n    return __awaiter(this, void 0, void 0, function* () {\n        console.log(\"Calling Gemini API for multimodal content with history:\", conversationHistory);\n        // Convert the conversation history to the format expected by the Gemini API\n        const geminiContents = conversationHistory.map((message) => {\n            // If content is a string, create a simple text part\n            if (typeof message.content === \"string\") {\n                return {\n                    role: mapRole(message.role),\n                    parts: [{ text: message.content }],\n                };\n            }\n            // If content is an array of ContentPart objects\n            else if (Array.isArray(message.content)) {\n                return {\n                    role: mapRole(message.role),\n                    parts: message.content.map((part) => {\n                        var _a;\n                        switch (part.type) {\n                            case \"text\":\n                                return { text: part.text || \"\" };\n                            case \"image\":\n                                return {\n                                    inline_data: {\n                                        mime_type: part.mimeType || \"image/jpeg\",\n                                        data: ((_a = part.mediaData) === null || _a === void 0 ? void 0 : _a.replace(/^data:image\\/[^;]+;base64,/, \"\")) ||\n                                            \"\",\n                                    },\n                                };\n                            case \"video\":\n                                // Handle video with file_uri format for processed videos\n                                if (\"file_uri\" in part && part.file_uri) {\n                                    return {\n                                        file_data: {\n                                            mime_type: part.mimeType || \"video/mp4\",\n                                            file_uri: part.file_uri,\n                                        },\n                                    };\n                                }\n                                else {\n                                    return {\n                                        file_data: {\n                                            mime_type: part.mimeType || \"video/mp4\",\n                                            file_uri: part.mediaData || \"\",\n                                        },\n                                    };\n                                }\n                            case \"audio\":\n                            case \"document\":\n                                // For now, these are handled as file_data in the API\n                                return {\n                                    file_data: {\n                                        mime_type: part.mimeType || \"\",\n                                        file_uri: part.mediaData || \"\",\n                                    },\n                                };\n                            default:\n                                return { text: \"Unsupported content type\" };\n                        }\n                    }),\n                };\n            }\n            // Fallback for any other unexpected format\n            return {\n                role: mapRole(message.role),\n                parts: [{ text: \"Unable to process content\" }],\n            };\n        });\n        // Configure the API request\n        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${settings.apiKey}`;\n        const requestBody = {\n            contents: geminiContents,\n            generation_config: {\n                temperature: 0.2,\n                topP: 0.95,\n                topK: 40,\n                maxOutputTokens: settings.maxTokens,\n            },\n            safety_settings: [\n                {\n                    category: \"HARM_CATEGORY_HARASSMENT\",\n                    threshold: \"BLOCK_MEDIUM_AND_ABOVE\",\n                },\n                {\n                    category: \"HARM_CATEGORY_HATE_SPEECH\",\n                    threshold: \"BLOCK_MEDIUM_AND_ABOVE\",\n                },\n                {\n                    category: \"HARM_CATEGORY_SEXUALLY_EXPLICIT\",\n                    threshold: \"BLOCK_MEDIUM_AND_ABOVE\",\n                },\n                {\n                    category: \"HARM_CATEGORY_DANGEROUS_CONTENT\",\n                    threshold: \"BLOCK_MEDIUM_AND_ABOVE\",\n                },\n            ],\n        };\n        console.log(\"Gemini API request:\", JSON.stringify(requestBody, null, 2));\n        try {\n            // Make the API request\n            const response = yield fetch(apiUrl, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                },\n                body: JSON.stringify(requestBody),\n            });\n            if (!response.ok) {\n                const errorText = yield response.text();\n                throw new Error(`Gemini API Error (${response.status}): ${errorText}`);\n            }\n            const data = yield response.json();\n            console.log(\"Gemini API response:\", data);\n            // Extract the text from the response\n            if (data.candidates &&\n                data.candidates[0] &&\n                data.candidates[0].content &&\n                data.candidates[0].content.parts &&\n                data.candidates[0].content.parts[0] &&\n                data.candidates[0].content.parts[0].text) {\n                return data.candidates[0].content.parts[0].text;\n            }\n            else {\n                throw new Error(\"Invalid response format from Gemini API\");\n            }\n        }\n        catch (error) {\n            console.error(\"Error calling Gemini Multimodal API:\", error);\n            throw error;\n        }\n    });\n}\n// Helper function to map our role types to Gemini API role types\nfunction mapRole(role) {\n    switch (role) {\n        case \"user\":\n            return \"user\";\n        case \"assistant\":\n            return \"model\";\n        case \"system\":\n            return \"user\"; // Gemini doesn't have a system role, we prepend this as user message\n        default:\n            return \"user\";\n    }\n}\n// New function to fetch an image and convert it to base64\nfunction fetchImageAsBase64(imageUrl) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            // Fetch the image data\n            const response = yield fetch(imageUrl, {\n                // Add options to handle CORS\n                mode: \"cors\",\n                cache: \"no-cache\",\n            });\n            if (!response.ok) {\n                throw new Error(`Failed to fetch image: ${response.status} ${response.statusText}`);\n            }\n            // Get the image data as blob\n            const blob = yield response.blob();\n            // Convert blob to base64\n            return new Promise((resolve, reject) => {\n                const reader = new FileReader();\n                reader.onloadend = () => {\n                    if (typeof reader.result === \"string\") {\n                        resolve(reader.result);\n                    }\n                    else {\n                        reject(new Error(\"Failed to convert image to base64\"));\n                    }\n                };\n                reader.onerror = reject;\n                reader.readAsDataURL(blob);\n            });\n        }\n        catch (error) {\n            console.error(\"Error fetching image:\", error);\n            throw error;\n        }\n    });\n}\n// Handler for multimodal requests (combined text and media)\nfunction handleMultimodalRequest(request, sender) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var _a;\n        console.log(\"Handling multimodal request:\", request);\n        try {\n            // Get settings\n            const settings = yield (0, utils_1.getSettings)();\n            // Set the tab ID\n            request.tabId = (_a = sender.tab) === null || _a === void 0 ? void 0 : _a.id;\n            // For videos, use the File API to upload the video\n            if (request.mediaType === types_1.MediaType.VIDEO) {\n                try {\n                    console.log(\"Processing video URL for multimodal request:\", request.mediaData);\n                    if (request.mediaData.startsWith(\"http\")) {\n                        // Upload the video to Gemini File API and get a file_uri\n                        const fileResult = yield uploadVideoToGeminiAPI(request.mediaData, settings.apiKey);\n                        request.mediaData = fileResult.file_uri;\n                        console.log(\"Successfully uploaded video to Gemini File API:\", request.mediaData);\n                    }\n                }\n                catch (error) {\n                    console.error(\"Error processing video for multimodal request:\", error);\n                    throw new Error(\"Failed to process the video component. Gemini requires videos to be processed through its File API. \" +\n                        \"This may be due to:\\n\\n\" +\n                        \" The video URL is not directly accessible\\n\" +\n                        \" The video format is not supported\\n\" +\n                        \" The video is too large or too long\\n\" +\n                        \" There was a network error during upload\\n\\n\" +\n                        \"Please try with a different video or check that the URL is publicly accessible.\");\n                }\n            }\n            // For images, use base64 data\n            if (request.mediaType === types_1.MediaType.IMAGE &&\n                !request.mediaData.startsWith(\"data:\")) {\n                try {\n                    console.log(\"Converting image URL to base64 for multimodal request\");\n                    request.mediaData = yield fetchImageAsBase64(request.mediaData);\n                }\n                catch (error) {\n                    console.error(\"Error converting image to base64:\", error);\n                    throw new Error(\"Failed to process the image component. This may be due to image protection by the website or CORS restrictions.\");\n                }\n            }\n            // Create conversation history\n            const conversationHistory = [];\n            // Add system message\n            conversationHistory.push({\n                role: \"system\",\n                content: getSystemPromptForMultimodal(request),\n            });\n            // Create user message with combined content parts\n            const userMessage = {\n                role: \"user\",\n                content: [],\n            };\n            // Create content parts array\n            const contentParts = [];\n            // Add text part first\n            contentParts.push({\n                type: \"text\",\n                text: `Please analyze this text and ${request.mediaType.toLowerCase()} together and explain their relationship: \"${request.text}\"`,\n            });\n            // Add media part based on type\n            if (request.mediaType === types_1.MediaType.IMAGE &&\n                request.mediaData.startsWith(\"data:\")) {\n                // For images with base64 data\n                contentParts.push({\n                    type: \"image\",\n                    mediaData: request.mediaData,\n                    mimeType: request.mimeType || \"image/jpeg\",\n                });\n            }\n            else if (request.mediaType === types_1.MediaType.VIDEO) {\n                // For videos using file_uri format\n                contentParts.push({\n                    type: \"video\",\n                    file_uri: request.mediaData, // This should now be a proper file_uri from the File API\n                    mimeType: request.mimeType || \"video/mp4\",\n                });\n            }\n            else {\n                // For other media types\n                contentParts.push({\n                    type: request.mediaType.toLowerCase(),\n                    mediaData: request.mediaData,\n                    mimeType: request.mimeType ||\n                        getMimeTypeForMedia(request.mediaType, request.mediaData),\n                });\n            }\n            // Set the content parts in the user message\n            userMessage.content = contentParts;\n            conversationHistory.push(userMessage);\n            // Call Gemini API for multimodal content\n            console.log(\"Calling Gemini API with multimodal content:\", conversationHistory);\n            const explanation = yield callGeminiMultimodalAPI(conversationHistory, settings);\n            // Create result conversation history\n            const resultConversationHistory = [\n                {\n                    role: \"user\",\n                    content: `Explain the relationship between this text: \"${request.text}\" and the ${request.mediaType.toLowerCase()}.`,\n                },\n                {\n                    role: \"assistant\",\n                    content: explanation,\n                },\n            ];\n            // Return the result\n            return {\n                explanation,\n                conversationHistory: resultConversationHistory,\n                originalText: `Text + ${request.mediaType} content`,\n            };\n        }\n        catch (error) {\n            console.error(\"Error handling multimodal request:\", error);\n            throw error;\n        }\n    });\n}\n// Get system prompt for multimodal content\nfunction getSystemPromptForMultimodal(request) {\n    // Start with generic instructions\n    let prompt = \"You are an AI assistant specialized in explaining how text and visual content relate to each other. \" +\n        \"Provide clear, educational explanations that identify connections between the two. \" +\n        \"Be comprehensive but concise.\";\n    // Add media type specific instructions\n    switch (request.mediaType) {\n        case types_1.MediaType.IMAGE:\n            prompt +=\n                \" Focus on how the image illustrates, contradicts, or relates to the text. \" +\n                    \"Consider elements like subject matter, composition, colors, and visual metaphors.\";\n            break;\n        case types_1.MediaType.VIDEO:\n            prompt +=\n                \" Describe how the video content relates to or expands upon the text. \" +\n                    \"Consider motion, timing, visual elements, and how they complement or contrast with the text.\";\n            break;\n        case types_1.MediaType.AUDIO:\n            prompt +=\n                \" Explain how the audio relates to the text. \" +\n                    \"Consider tone, mood, spoken content, and how the audio enhances understanding of the text.\";\n            break;\n        case types_1.MediaType.DOCUMENT:\n            prompt +=\n                \" Analyze how the document content relates to or provides context for the text. \" +\n                    \"Consider structure, formatting, and content relationships.\";\n            break;\n    }\n    // Add context information\n    if (request.contextText) {\n        prompt += `\\n\\nThe text was found in this broader context (which may include CSS that should be ignored unless directly relevant): \"${request.contextText}\"`;\n    }\n    if (request.mediaContextText) {\n        prompt += `\\n\\nThe ${request.mediaType.toLowerCase()} was found with this context: \"${request.mediaContextText}\"`;\n    }\n    return prompt;\n}\n","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DatabaseError = void 0;\nexports.initDatabase = initDatabase;\nexports.addHistoryEntry = addHistoryEntry;\nexports.getHistoryEntry = getHistoryEntry;\nexports.getAllHistoryEntries = getAllHistoryEntries;\nexports.clearOldHistoryEntries = clearOldHistoryEntries;\nexports.getHistoryEntriesInRange = getHistoryEntriesInRange;\nexports.searchHistoryEntries = searchHistoryEntries;\nconst DB_NAME = \"ai_dictionary_plus\";\nconst DB_VERSION = 1;\nconst HISTORY_STORE = \"history\";\nconst SETTINGS_STORE = \"settings\";\nclass DatabaseError extends Error {\n    constructor(message) {\n        super(message);\n        this.name = \"DatabaseError\";\n    }\n}\nexports.DatabaseError = DatabaseError;\nfunction initDatabase() {\n    return __awaiter(this, void 0, void 0, function* () {\n        return new Promise((resolve, reject) => {\n            const request = indexedDB.open(DB_NAME, DB_VERSION);\n            request.onerror = () => {\n                reject(new DatabaseError(\"Failed to open database\"));\n            };\n            request.onsuccess = () => {\n                resolve(request.result);\n            };\n            request.onupgradeneeded = (event) => {\n                const db = event.target.result;\n                // Create history store with indexes\n                if (!db.objectStoreNames.contains(HISTORY_STORE)) {\n                    const historyStore = db.createObjectStore(HISTORY_STORE, {\n                        keyPath: \"id\",\n                    });\n                    historyStore.createIndex(\"timestamp\", \"timestamp\");\n                    historyStore.createIndex(\"text\", \"text\");\n                    historyStore.createIndex(\"pageUrl\", \"pageUrl\");\n                }\n                // Create settings store\n                if (!db.objectStoreNames.contains(SETTINGS_STORE)) {\n                    db.createObjectStore(SETTINGS_STORE);\n                }\n            };\n        });\n    });\n}\n// Add a history entry\nfunction addHistoryEntry(entry) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const db = yield initDatabase();\n        return new Promise((resolve, reject) => {\n            const transaction = db.transaction(HISTORY_STORE, \"readwrite\");\n            const store = transaction.objectStore(HISTORY_STORE);\n            const request = store.add(entry);\n            request.onerror = () => {\n                reject(new DatabaseError(\"Failed to add history entry\"));\n            };\n            request.onsuccess = () => {\n                resolve();\n            };\n        });\n    });\n}\n// Get a history entry by ID\nfunction getHistoryEntry(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const db = yield initDatabase();\n        return new Promise((resolve, reject) => {\n            const transaction = db.transaction(HISTORY_STORE, \"readonly\");\n            const store = transaction.objectStore(HISTORY_STORE);\n            const request = store.get(id);\n            request.onerror = () => {\n                reject(new DatabaseError(\"Failed to get history entry\"));\n            };\n            request.onsuccess = () => {\n                resolve(request.result || null);\n            };\n        });\n    });\n}\n// Get all history entries\nfunction getAllHistoryEntries() {\n    return __awaiter(this, void 0, void 0, function* () {\n        const db = yield initDatabase();\n        return new Promise((resolve, reject) => {\n            const transaction = db.transaction(HISTORY_STORE, \"readonly\");\n            const store = transaction.objectStore(HISTORY_STORE);\n            const request = store.getAll();\n            request.onerror = () => {\n                reject(new DatabaseError(\"Failed to get history entries\"));\n            };\n            request.onsuccess = () => {\n                resolve(request.result);\n            };\n        });\n    });\n}\n// Clear history entries older than the specified date\nfunction clearOldHistoryEntries(cutoffTime) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const db = yield initDatabase();\n        return new Promise((resolve, reject) => {\n            const transaction = db.transaction(HISTORY_STORE, \"readwrite\");\n            const store = transaction.objectStore(HISTORY_STORE);\n            const index = store.index(\"timestamp\");\n            // Use a cursor to iterate through old entries\n            const range = IDBKeyRange.upperBound(cutoffTime);\n            const request = index.openCursor(range);\n            request.onerror = () => {\n                reject(new DatabaseError(\"Failed to clear old history entries\"));\n            };\n            request.onsuccess = (event) => {\n                const cursor = event.target.result;\n                if (cursor) {\n                    store.delete(cursor.primaryKey);\n                    cursor.continue();\n                }\n                else {\n                    resolve();\n                }\n            };\n        });\n    });\n}\n// Get history entries within a date range\nfunction getHistoryEntriesInRange(startTime, endTime) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const db = yield initDatabase();\n        return new Promise((resolve, reject) => {\n            const transaction = db.transaction(HISTORY_STORE, \"readonly\");\n            const store = transaction.objectStore(HISTORY_STORE);\n            const index = store.index(\"timestamp\");\n            const range = IDBKeyRange.bound(startTime, endTime);\n            const request = index.getAll(range);\n            request.onerror = () => {\n                reject(new DatabaseError(\"Failed to get history entries in range\"));\n            };\n            request.onsuccess = () => {\n                resolve(request.result);\n            };\n        });\n    });\n}\n// Search history entries by text\nfunction searchHistoryEntries(searchText) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const db = yield initDatabase();\n        return new Promise((resolve, reject) => {\n            const transaction = db.transaction(HISTORY_STORE, \"readonly\");\n            const store = transaction.objectStore(HISTORY_STORE);\n            const request = store.getAll();\n            request.onerror = () => {\n                reject(new DatabaseError(\"Failed to search history entries\"));\n            };\n            request.onsuccess = () => {\n                const entries = request.result;\n                const searchLower = searchText.toLowerCase();\n                const results = entries.filter((entry) => entry.text.toLowerCase().includes(searchLower) ||\n                    entry.explanation.toLowerCase().includes(searchLower));\n                resolve(results);\n            };\n        });\n    });\n}\n","\"use strict\";\n// Type definitions for the extension\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MessageType = exports.MediaType = exports.DEFAULT_SETTINGS = void 0;\n// Default settings\nexports.DEFAULT_SETTINGS = {\n    apiKey: \"\",\n    perplexityApiKey: \"\",\n    theme: \"auto\",\n    maxTokens: 2000,\n    cacheEnabled: true,\n    cacheExpiry: 24,\n    webSearchEnabled: true,\n    keyboardShortcut: {\n        key: \"E\",\n        ctrlKey: false,\n        shiftKey: true,\n        altKey: false,\n        metaKey: true, // Cmd key on Mac\n    },\n    multimodalEnabled: true,\n    historyRetention: 7, // Default to 7 days\n};\n// Media types supported by the extension\nvar MediaType;\n(function (MediaType) {\n    MediaType[\"TEXT\"] = \"text\";\n    MediaType[\"IMAGE\"] = \"image\";\n    MediaType[\"DOCUMENT\"] = \"document\";\n    MediaType[\"AUDIO\"] = \"audio\";\n    MediaType[\"VIDEO\"] = \"video\";\n})(MediaType || (exports.MediaType = MediaType = {}));\n// Message types for communication between components\nvar MessageType;\n(function (MessageType) {\n    MessageType[\"EXPLAIN_TEXT\"] = \"EXPLAIN_TEXT\";\n    MessageType[\"EXPLANATION_RESULT\"] = \"EXPLANATION_RESULT\";\n    MessageType[\"FOLLOW_UP_QUESTION\"] = \"FOLLOW_UP_QUESTION\";\n    MessageType[\"WEB_SEARCH\"] = \"WEB_SEARCH\";\n    MessageType[\"WEB_SEARCH_RESULT\"] = \"WEB_SEARCH_RESULT\";\n    MessageType[\"OPEN_CHAT\"] = \"OPEN_CHAT\";\n    MessageType[\"GET_SETTINGS\"] = \"GET_SETTINGS\";\n    MessageType[\"SAVE_SETTINGS\"] = \"SAVE_SETTINGS\";\n    MessageType[\"SETTINGS_UPDATED\"] = \"SETTINGS_UPDATED\";\n    MessageType[\"ERROR\"] = \"ERROR\";\n    // New message types for multimedia\n    MessageType[\"EXPLAIN_MEDIA\"] = \"EXPLAIN_MEDIA\";\n    MessageType[\"MEDIA_EXPLANATION_RESULT\"] = \"MEDIA_EXPLANATION_RESULT\";\n    // New message type for multimodal content (text + media combined)\n    MessageType[\"EXPLAIN_MULTIMODAL\"] = \"EXPLAIN_MULTIMODAL\";\n})(MessageType || (exports.MessageType = MessageType = {}));\n","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isValidText = exports.generateCacheKey = exports.clearExpiredCache = exports.getCacheItem = exports.setCacheItem = exports.cleanupHistoryEntries = exports.getHistoryLogEntry = exports.addHistoryLogEntry = exports.getHistoryLog = exports.HISTORY_LOG_KEY = exports.saveSettings = exports.getSettings = exports.getTheme = exports.getSystemTheme = void 0;\nexports.debounce = debounce;\n/// <reference types=\"chrome\" />\nconst types_1 = require(\"./types\");\nconst db_1 = require(\"./db\");\n// Get current system theme (light or dark)\nconst getSystemTheme = () => {\n    return window.matchMedia &&\n        window.matchMedia(\"(prefers-color-scheme: dark)\").matches\n        ? \"dark\"\n        : \"light\";\n};\nexports.getSystemTheme = getSystemTheme;\n// Determine theme based on settings\nconst getTheme = (settings) => {\n    if (settings.theme === \"auto\") {\n        return (0, exports.getSystemTheme)();\n    }\n    return settings.theme;\n};\nexports.getTheme = getTheme;\n// Get settings from storage\nconst getSettings = () => __awaiter(void 0, void 0, void 0, function* () {\n    return new Promise((resolve) => {\n        chrome.storage.sync.get(\"settings\", (result) => {\n            // If no settings found, use defaults\n            if (!result.settings) {\n                resolve(Object.assign({}, types_1.DEFAULT_SETTINGS));\n                return;\n            }\n            // Merge saved settings with defaults to ensure all properties exist\n            const mergedSettings = Object.assign(Object.assign(Object.assign({}, types_1.DEFAULT_SETTINGS), result.settings), { \n                // Handle nested objects like keyboardShortcut\n                keyboardShortcut: Object.assign(Object.assign({}, types_1.DEFAULT_SETTINGS.keyboardShortcut), (result.settings.keyboardShortcut || {})) });\n            resolve(mergedSettings);\n        });\n    });\n});\nexports.getSettings = getSettings;\n// Save settings to storage\nconst saveSettings = (settings) => __awaiter(void 0, void 0, void 0, function* () {\n    return new Promise((resolve) => {\n        chrome.storage.sync.set({ settings }, () => {\n            resolve();\n        });\n    });\n});\nexports.saveSettings = saveSettings;\n// History log functions\nexports.HISTORY_LOG_KEY = \"explanation_history\";\n// Get the history log\nconst getHistoryLog = () => __awaiter(void 0, void 0, void 0, function* () {\n    return new Promise((resolve) => {\n        chrome.storage.local.get(exports.HISTORY_LOG_KEY, (result) => {\n            const historyLog = result[exports.HISTORY_LOG_KEY];\n            if (!historyLog) {\n                // Initialize empty history log if it doesn't exist\n                const emptyLog = {\n                    entries: [],\n                    lastUpdated: Date.now(),\n                };\n                resolve(emptyLog);\n            }\n            else {\n                resolve(historyLog);\n            }\n        });\n    });\n});\nexports.getHistoryLog = getHistoryLog;\n// Add an entry to the history log\nconst addHistoryLogEntry = (entry) => __awaiter(void 0, void 0, void 0, function* () {\n    // Generate a unique ID\n    const id = `hist_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    // Create the full entry\n    const fullEntry = Object.assign(Object.assign({}, entry), { id, timestamp: Date.now() });\n    // Add to IndexedDB\n    yield (0, db_1.addHistoryEntry)(fullEntry);\n    return id;\n});\nexports.addHistoryLogEntry = addHistoryLogEntry;\n// Get a history log entry by ID\nconst getHistoryLogEntry = (id) => __awaiter(void 0, void 0, void 0, function* () {\n    return (0, db_1.getHistoryEntry)(id);\n});\nexports.getHistoryLogEntry = getHistoryLogEntry;\n// Clear entries based on retention settings\nconst cleanupHistoryEntries = (settings) => __awaiter(void 0, void 0, void 0, function* () {\n    // If retention is set to 'forever', don't clean up\n    if (settings.historyRetention === \"forever\") {\n        return;\n    }\n    // Calculate cutoff time based on retention days\n    const cutoffTime = Date.now() - settings.historyRetention * 24 * 60 * 60 * 1000;\n    // Clear old entries\n    yield (0, db_1.clearOldHistoryEntries)(cutoffTime);\n});\nexports.cleanupHistoryEntries = cleanupHistoryEntries;\n// Set an item in the cache with history log reference\nconst setCacheItem = (key, data, expiryHours, historyLogId) => __awaiter(void 0, void 0, void 0, function* () {\n    const cacheItem = {\n        data,\n        timestamp: Date.now() + expiryHours * 60 * 60 * 1000,\n        historyLogId,\n    };\n    yield chrome.storage.local.set({ [key]: cacheItem });\n});\nexports.setCacheItem = setCacheItem;\n// Get an item from the cache and its history log entry if available\nconst getCacheItem = (key) => __awaiter(void 0, void 0, void 0, function* () {\n    return new Promise((resolve) => {\n        chrome.storage.local.get(key, (result) => __awaiter(void 0, void 0, void 0, function* () {\n            const cacheItem = result[key];\n            // If no cache or expired\n            if (!cacheItem || Date.now() > cacheItem.timestamp) {\n                resolve({ data: null, historyEntry: null });\n                return;\n            }\n            // Get history entry if available\n            let historyEntry = null;\n            if (cacheItem.historyLogId) {\n                historyEntry = yield (0, exports.getHistoryLogEntry)(cacheItem.historyLogId);\n            }\n            resolve({ data: cacheItem.data, historyEntry });\n        }));\n    });\n});\nexports.getCacheItem = getCacheItem;\n// Clear expired cache items\nconst clearExpiredCache = () => __awaiter(void 0, void 0, void 0, function* () {\n    const allCache = (yield chrome.storage.local.get(null));\n    const now = Date.now();\n    const keysToRemove = [];\n    for (const [key, value] of Object.entries(allCache)) {\n        const cacheValue = value;\n        if (key.startsWith(\"cache_\") &&\n            cacheValue.timestamp &&\n            cacheValue.timestamp < now) {\n            keysToRemove.push(key);\n        }\n    }\n    if (keysToRemove.length > 0) {\n        yield chrome.storage.local.remove(keysToRemove);\n    }\n});\nexports.clearExpiredCache = clearExpiredCache;\n// Generate a cache key from text\nconst generateCacheKey = (text) => {\n    // Simple hash function for strings\n    let hash = 0;\n    if (text.length === 0)\n        return \"cache_empty\";\n    for (let i = 0; i < text.length; i++) {\n        const char = text.charCodeAt(i);\n        hash = (hash << 5) - hash + char;\n        hash = hash & hash; // Convert to 32bit integer\n    }\n    return `cache_${hash}`;\n};\nexports.generateCacheKey = generateCacheKey;\n// Debounce function to prevent too many API calls\nfunction debounce(func, waitFor) {\n    let timeout = null;\n    return function (...args) {\n        if (timeout !== null) {\n            clearTimeout(timeout);\n        }\n        timeout = setTimeout(() => func(...args), waitFor);\n    };\n}\n// Function to check if the text is valid for an explanation\nconst isValidText = (text) => {\n    if (!text)\n        return false;\n    text = text.trim();\n    return text.length > 0 && text.length <= 1000; // Arbitrary limit to prevent large requests\n};\nexports.isValidText = isValidText;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./src/background/index.ts\");\n",""],"names":[],"sourceRoot":""}