{"version":3,"file":"background.js","mappings":";;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC5dA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACnIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AEvBA;AACA;AACA;AACA","sources":["webpack://ai-dictionary-plus/./src/background/index.ts","webpack://ai-dictionary-plus/./src/shared/types.ts","webpack://ai-dictionary-plus/./src/shared/utils.ts","webpack://ai-dictionary-plus/webpack/bootstrap","webpack://ai-dictionary-plus/webpack/before-startup","webpack://ai-dictionary-plus/webpack/startup","webpack://ai-dictionary-plus/webpack/after-startup"],"sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/// <reference types=\"chrome\" />\nconst types_1 = require(\"../shared/types\");\nconst utils_1 = require(\"../shared/utils\");\n// Initialize context menu\nchrome.runtime.onInstalled.addListener(() => {\n    // Clear any existing context menu items first\n    chrome.contextMenus.removeAll(() => {\n        // Create our context menu item\n        chrome.contextMenus.create({\n            id: \"explainText\",\n            title: \"Explain with AI Dictionary+\",\n            contexts: [\"selection\"],\n        });\n    });\n    // Clear expired cache items on startup\n    (0, utils_1.clearExpiredCache)();\n});\n// Handle context menu clicks\nchrome.contextMenus.onClicked.addListener((info, tab) => {\n    console.log(\"Context menu clicked:\", info, tab);\n    if (info.menuItemId === \"explainText\" && info.selectionText && (tab === null || tab === void 0 ? void 0 : tab.id)) {\n        console.log(\"Sending message to tab\", tab.id, \"with text:\", info.selectionText);\n        // Send a message to the content script to show the tooltip\n        try {\n            chrome.tabs.sendMessage(tab.id, {\n                type: types_1.MessageType.EXPLAIN_TEXT,\n                payload: {\n                    text: info.selectionText,\n                },\n            }, (response) => {\n                console.log(\"Response from content script:\", response);\n                if (chrome.runtime.lastError) {\n                    console.error(\"Error sending message to content script:\", chrome.runtime.lastError);\n                }\n            });\n        }\n        catch (error) {\n            console.error(\"Error in context menu handler:\", error);\n        }\n    }\n});\n// Message listener\nchrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n    var _a, _b, _c;\n    console.log(\"Background received message:\", message, \"from\", sender);\n    const { type, payload } = message;\n    switch (type) {\n        case types_1.MessageType.EXPLAIN_TEXT:\n            console.log(\"Background handling EXPLAIN_TEXT request\");\n            handleExplainText(payload, (_a = sender.tab) === null || _a === void 0 ? void 0 : _a.id)\n                .then((result) => {\n                console.log(\"Sending explanation result:\", result);\n                sendResponse(result);\n            })\n                .catch((error) => {\n                console.error(\"Error in handleExplainText:\", error);\n                sendResponse({\n                    explanation: \"An error occurred while processing your request.\",\n                    originalText: payload.text,\n                    error: error instanceof Error ? error.message : String(error),\n                    conversationHistory: [],\n                });\n            });\n            return true; // Keep the messaging channel open for the async response\n        case types_1.MessageType.FOLLOW_UP_QUESTION:\n            console.log(\"Background handling FOLLOW_UP_QUESTION request\");\n            handleFollowUpQuestion(payload, (_b = sender.tab) === null || _b === void 0 ? void 0 : _b.id)\n                .then(sendResponse)\n                .catch((error) => {\n                console.error(\"Error in handleFollowUpQuestion:\", error);\n                sendResponse({\n                    explanation: \"An error occurred while processing your follow-up question.\",\n                    originalText: payload.originalText,\n                    error: error instanceof Error ? error.message : String(error),\n                    conversationHistory: payload.conversationHistory || [],\n                });\n            });\n            return true;\n        case types_1.MessageType.WEB_SEARCH:\n            console.log(\"Background handling WEB_SEARCH request\");\n            handleWebSearch(payload, (_c = sender.tab) === null || _c === void 0 ? void 0 : _c.id)\n                .then(sendResponse)\n                .catch((error) => {\n                console.error(\"Error in handleWebSearch:\", error);\n                sendResponse({\n                    explanation: payload.originalExplanation,\n                    originalText: payload.text,\n                    error: error instanceof Error ? error.message : String(error),\n                    conversationHistory: [],\n                    webSearched: false,\n                });\n            });\n            return true;\n        case types_1.MessageType.GET_SETTINGS:\n            (0, utils_1.getSettings)().then(sendResponse);\n            return true;\n        case types_1.MessageType.SAVE_SETTINGS:\n            (0, utils_1.saveSettings)(payload)\n                .then(() => {\n                sendResponse({ success: true });\n                // Notify any open tabs about the settings change\n                chrome.tabs.query({}, (tabs) => {\n                    tabs.forEach((tab) => {\n                        if (tab.id) {\n                            chrome.tabs\n                                .sendMessage(tab.id, {\n                                type: types_1.MessageType.SETTINGS_UPDATED,\n                                payload,\n                            })\n                                .catch(() => {\n                                // Ignore errors - tab might not have a content script\n                            });\n                        }\n                    });\n                });\n            })\n                .catch((error) => {\n                console.error(\"Error saving settings:\", error);\n                sendResponse({\n                    success: false,\n                    error: error instanceof Error ? error.message : String(error),\n                });\n            });\n            return true;\n        case types_1.MessageType.OPEN_CHAT:\n            console.log(\"Handling chat open request with data:\", payload);\n            sendResponse({ success: true });\n            return true;\n        default:\n            console.log(\"Unknown message type:\", type);\n            return false;\n    }\n});\n// Handle explain text requests\nfunction handleExplainText(request, tabId) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            const settings = yield (0, utils_1.getSettings)();\n            if (!settings.apiKey) {\n                return {\n                    explanation: \"Please set your API key in the extension options\",\n                    originalText: request.text,\n                    error: \"No API key\",\n                    conversationHistory: [],\n                };\n            }\n            // Check cache if enabled\n            if (settings.cacheEnabled && !request.skipCache) {\n                const cacheKey = (0, utils_1.generateCacheKey)(request.text);\n                const cachedResult = yield (0, utils_1.getCacheItem)(cacheKey);\n                if (cachedResult) {\n                    return cachedResult;\n                }\n            }\n            // Generate enhanced conversation history with system prompts\n            const enhancedConversationHistory = [\n                // System prompt with instructions\n                {\n                    role: \"system\",\n                    content: \"You are AI Dictionary+, a helpful AI assistant integrated into a browser extension. \" +\n                        \"Your purpose is to explain concepts, answer questions, and engage in helpful conversation. \" +\n                        \"You have access to the user's current context and can explain technical terms, concepts, and provide detailed information on a wide range of topics. \" +\n                        \"Always be thorough in your explanations, providing detailed context and real-world examples where applicable. \" +\n                        \"IMPORTANT: Ignore any CSS styling information in the context unless the user is specifically asking about CSS. \" +\n                        \"Focus on explaining the core concept, not the styling or formatting of the webpage. \" +\n                        \"When explaining technical terms, provide clear definitions, examples of use, and relevant context.\",\n                },\n                // Add context about what the user is looking at\n                {\n                    role: \"system\",\n                    content: `The user has selected this text to be explained: \"${request.text}\". ` +\n                        (request.contextText\n                            ? `Additional context surrounding the selection (which may include CSS that should be ignored unless directly relevant): ${request.contextText}`\n                            : \"No additional context is available.\"),\n                },\n                // User question\n                {\n                    role: \"user\",\n                    content: `Explain this clearly and concisely: \"${request.text}\"`,\n                },\n            ];\n            // Call Gemini API with enhanced context\n            const explanation = yield callGeminiAPI(enhancedConversationHistory, settings);\n            // Create result - only include the actual conversation in the history (not system messages)\n            // This prevents UI confusion with system messages appearing in the chat\n            const resultConversationHistory = [\n                {\n                    role: \"user\",\n                    content: `Explain this clearly and concisely: \"${request.text}\"`,\n                },\n                {\n                    role: \"assistant\",\n                    content: explanation,\n                },\n            ];\n            // Create result\n            const result = {\n                explanation,\n                originalText: request.text,\n                conversationHistory: resultConversationHistory,\n            };\n            // Cache result if enabled\n            if (settings.cacheEnabled) {\n                const cacheKey = (0, utils_1.generateCacheKey)(request.text);\n                yield (0, utils_1.setCacheItem)(cacheKey, result, settings.cacheExpiry);\n            }\n            return result;\n        }\n        catch (error) {\n            console.error(\"Error explaining text:\", error);\n            return {\n                explanation: \"An error occurred while getting the explanation.\",\n                originalText: request.text,\n                error: error instanceof Error ? error.message : String(error),\n                conversationHistory: [],\n            };\n        }\n    });\n}\n// Handle follow-up questions\nfunction handleFollowUpQuestion(request, tabId) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            const settings = yield (0, utils_1.getSettings)();\n            if (!settings.apiKey) {\n                return {\n                    explanation: \"Please set your API key in the extension options\",\n                    originalText: request.originalText,\n                    error: \"No API key\",\n                    conversationHistory: [],\n                };\n            }\n            // Enhanced conversation history with system prompts for better context\n            const enhancedConversationHistory = [];\n            // Add system prompt about AI Dictionary+ capabilities\n            enhancedConversationHistory.push({\n                role: \"system\",\n                content: \"You are AI Dictionary+, a helpful AI assistant integrated into a browser extension. \" +\n                    \"Your purpose is to explain concepts, answer questions, and engage in helpful conversation. \" +\n                    \"You have access to the user's current context and can explain technical terms, concepts, and provide detailed information on a wide range of topics. \" +\n                    \"Always be thorough in your explanations, providing detailed context and real-world examples where applicable. \" +\n                    \"IMPORTANT: Ignore any CSS styling information in the context unless the user is specifically asking about CSS. \" +\n                    \"Focus on explaining the core concept, not the styling or formatting of the webpage. \" +\n                    \"When explaining technical terms, provide clear definitions, examples of use, and relevant context.\",\n            });\n            // Add context about the content the user is viewing if available\n            if (request.originalText) {\n                enhancedConversationHistory.push({\n                    role: \"system\",\n                    content: `The user is currently looking at content related to: \"${request.originalText}\". Tailor your responses to be relevant to this context when appropriate, but ignore CSS styling information unless specifically asked about it.`,\n                });\n            }\n            // Add existing conversation history\n            enhancedConversationHistory.push(...request.conversationHistory);\n            // Add current user question\n            enhancedConversationHistory.push({\n                role: \"user\",\n                content: request.question,\n            });\n            // Use the user's configured token limit (no arbitrary doubling)\n            const explanation = yield callGeminiAPI(enhancedConversationHistory, settings);\n            // Create result - only include the actual conversation in the history (not system messages)\n            // This prevents UI confusion with system messages appearing in the chat\n            const resultConversationHistory = [\n                ...request.conversationHistory,\n                { role: \"user\", content: request.question },\n                { role: \"assistant\", content: explanation },\n            ];\n            const result = {\n                explanation,\n                originalText: request.originalText,\n                conversationHistory: resultConversationHistory,\n            };\n            return result;\n        }\n        catch (error) {\n            console.error(\"Error with follow-up question:\", error);\n            return {\n                explanation: \"An error occurred while getting the explanation.\",\n                originalText: request.originalText,\n                error: error instanceof Error ? error.message : String(error),\n                conversationHistory: request.conversationHistory,\n            };\n        }\n    });\n}\n// Call Gemini API\nfunction callGeminiAPI(conversationHistory, settings) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var _a, _b, _c;\n        const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${settings.apiKey}`;\n        // Format the conversation for Gemini\n        const contents = conversationHistory.map((message) => {\n            // Map roles from our app format to Gemini API format\n            let apiRole = \"user\";\n            if (message.role === \"assistant\") {\n                apiRole = \"model\";\n            }\n            else if (message.role === \"system\") {\n                // For system messages, we'll use \"user\" role but add a prefix to indicate system instructions\n                return {\n                    parts: [\n                        {\n                            text: \"[SYSTEM INSTRUCTION]\\n\" + message.content,\n                        },\n                    ],\n                    role: \"user\",\n                };\n            }\n            return {\n                parts: [\n                    {\n                        text: message.content,\n                    },\n                ],\n                role: apiRole,\n            };\n        });\n        // Additional system instructions to include in the prompt\n        const enhancedInstructions = {\n            safetySettings: [\n                {\n                    category: \"HARM_CATEGORY_HARASSMENT\",\n                    threshold: \"BLOCK_MEDIUM_AND_ABOVE\",\n                },\n                {\n                    category: \"HARM_CATEGORY_HATE_SPEECH\",\n                    threshold: \"BLOCK_MEDIUM_AND_ABOVE\",\n                },\n                {\n                    category: \"HARM_CATEGORY_SEXUALLY_EXPLICIT\",\n                    threshold: \"BLOCK_MEDIUM_AND_ABOVE\",\n                },\n                {\n                    category: \"HARM_CATEGORY_DANGEROUS_CONTENT\",\n                    threshold: \"BLOCK_MEDIUM_AND_ABOVE\",\n                },\n            ],\n            generationConfig: {\n                maxOutputTokens: settings.maxTokens,\n                temperature: 0.2,\n                topP: 0.95,\n                topK: 40,\n            },\n        };\n        const payload = Object.assign({ contents }, enhancedInstructions);\n        console.log(\"Sending payload to Gemini:\", JSON.stringify(payload));\n        const response = yield fetch(url, {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n            },\n            body: JSON.stringify(payload),\n        });\n        if (!response.ok) {\n            const errorText = yield response.text();\n            throw new Error(`Gemini API error: ${response.status} - ${errorText}`);\n        }\n        const data = yield response.json();\n        // Extract text from response\n        if (data.candidates &&\n            ((_b = (_a = data.candidates[0]) === null || _a === void 0 ? void 0 : _a.content) === null || _b === void 0 ? void 0 : _b.parts) &&\n            ((_c = data.candidates[0].content.parts[0]) === null || _c === void 0 ? void 0 : _c.text)) {\n            return data.candidates[0].content.parts[0].text;\n        }\n        throw new Error(\"Unexpected API response format\");\n    });\n}\n// Handle web search requests\nfunction handleWebSearch(request, tabId) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            const settings = yield (0, utils_1.getSettings)();\n            if (!settings.perplexityApiKey) {\n                return {\n                    explanation: request.originalExplanation,\n                    originalText: request.text,\n                    error: \"Please set your Perplexity API key in the extension options\",\n                    conversationHistory: [],\n                    webSearched: false,\n                };\n            }\n            // Call Perplexity API to get enhanced explanation and citations\n            const { explanation, citations } = yield callPerplexityAPI(request.text, request.originalExplanation, settings);\n            console.log(\"Web search result:\", { explanation, citations });\n            // Create result\n            const result = {\n                explanation,\n                originalText: request.text,\n                conversationHistory: [\n                    {\n                        role: \"user\",\n                        content: `Please explain: \"${request.text}\"`,\n                    },\n                    {\n                        role: \"assistant\",\n                        content: explanation,\n                    },\n                ],\n                webSearched: true,\n                citations,\n            };\n            return result;\n        }\n        catch (error) {\n            console.error(\"Error in web search:\", error);\n            return {\n                explanation: request.originalExplanation,\n                originalText: request.text,\n                error: error instanceof Error ? error.message : String(error),\n                conversationHistory: [],\n                webSearched: false,\n            };\n        }\n    });\n}\n// Call Perplexity API with the sonar model\nfunction callPerplexityAPI(query, originalExplanation, settings) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var _a, _b;\n        const url = \"https://api.perplexity.ai/chat/completions\";\n        const systemPrompt = `You are an AI assistant that provides enhanced explanations by searching the web for accurate and up-to-date information. You are given a query and an initial explanation. Your task is to:\n1. Enhance the explanation with additional facts, context, and details from the web.\n2. Maintain a clear, educational tone.\n3. Add citation references like [1], [2], etc. at relevant points in your response.\n4. Format your response using Markdown for better readability.\n5. Keep your response concise and focused on the topic.`;\n        const payload = {\n            model: \"sonar\",\n            messages: [\n                {\n                    role: \"system\",\n                    content: systemPrompt,\n                },\n                {\n                    role: \"user\",\n                    content: `I need an enhanced explanation of: \"${query}\"\\n\\nHere's the initial explanation to improve upon:\\n${originalExplanation}\\n\\nPlease enhance this with web search results and add citations.`,\n                },\n            ],\n            max_tokens: settings.maxTokens,\n            temperature: 0.2,\n        };\n        const response = yield fetch(url, {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n                Authorization: `Bearer ${settings.perplexityApiKey}`,\n            },\n            body: JSON.stringify(payload),\n        });\n        if (!response.ok) {\n            const errorText = yield response.text();\n            throw new Error(`Perplexity API error: ${response.status} - ${errorText}`);\n        }\n        const data = yield response.json();\n        console.log(\"Perplexity API response:\", data);\n        // Extract response text\n        if (data.choices && ((_b = (_a = data.choices[0]) === null || _a === void 0 ? void 0 : _a.message) === null || _b === void 0 ? void 0 : _b.content)) {\n            const explanation = data.choices[0].message.content;\n            // Extract citations directly from the API response\n            const citations = data.citations || [];\n            return { explanation, citations };\n        }\n        throw new Error(\"Unexpected API response format from Perplexity\");\n    });\n}\n","\"use strict\";\n// Type definitions for the extension\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MessageType = exports.DEFAULT_SETTINGS = void 0;\n// Default settings\nexports.DEFAULT_SETTINGS = {\n    apiKey: \"\",\n    perplexityApiKey: \"\",\n    theme: \"auto\",\n    maxTokens: 2000,\n    cacheEnabled: true,\n    cacheExpiry: 24,\n    webSearchEnabled: true,\n    keyboardShortcut: {\n        key: \"E\",\n        ctrlKey: false,\n        shiftKey: true,\n        altKey: false,\n        metaKey: true, // Cmd key on Mac\n    },\n};\n// Message types for communication between components\nvar MessageType;\n(function (MessageType) {\n    MessageType[\"EXPLAIN_TEXT\"] = \"EXPLAIN_TEXT\";\n    MessageType[\"EXPLANATION_RESULT\"] = \"EXPLANATION_RESULT\";\n    MessageType[\"FOLLOW_UP_QUESTION\"] = \"FOLLOW_UP_QUESTION\";\n    MessageType[\"WEB_SEARCH\"] = \"WEB_SEARCH\";\n    MessageType[\"WEB_SEARCH_RESULT\"] = \"WEB_SEARCH_RESULT\";\n    MessageType[\"OPEN_CHAT\"] = \"OPEN_CHAT\";\n    MessageType[\"GET_SETTINGS\"] = \"GET_SETTINGS\";\n    MessageType[\"SAVE_SETTINGS\"] = \"SAVE_SETTINGS\";\n    MessageType[\"SETTINGS_UPDATED\"] = \"SETTINGS_UPDATED\";\n    MessageType[\"ERROR\"] = \"ERROR\";\n})(MessageType || (exports.MessageType = MessageType = {}));\n","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isValidText = exports.generateCacheKey = exports.clearExpiredCache = exports.getCacheItem = exports.setCacheItem = exports.saveSettings = exports.getSettings = exports.getTheme = exports.getSystemTheme = void 0;\nexports.debounce = debounce;\n/// <reference types=\"chrome\" />\nconst types_1 = require(\"./types\");\n// Get current system theme (light or dark)\nconst getSystemTheme = () => {\n    return window.matchMedia &&\n        window.matchMedia(\"(prefers-color-scheme: dark)\").matches\n        ? \"dark\"\n        : \"light\";\n};\nexports.getSystemTheme = getSystemTheme;\n// Determine theme based on settings\nconst getTheme = (settings) => {\n    if (settings.theme === \"auto\") {\n        return (0, exports.getSystemTheme)();\n    }\n    return settings.theme;\n};\nexports.getTheme = getTheme;\n// Get settings from storage\nconst getSettings = () => __awaiter(void 0, void 0, void 0, function* () {\n    return new Promise((resolve) => {\n        chrome.storage.sync.get(\"settings\", (result) => {\n            // If no settings found, use defaults\n            if (!result.settings) {\n                resolve(Object.assign({}, types_1.DEFAULT_SETTINGS));\n                return;\n            }\n            // Merge saved settings with defaults to ensure all properties exist\n            const mergedSettings = Object.assign(Object.assign(Object.assign({}, types_1.DEFAULT_SETTINGS), result.settings), { \n                // Handle nested objects like keyboardShortcut\n                keyboardShortcut: Object.assign(Object.assign({}, types_1.DEFAULT_SETTINGS.keyboardShortcut), (result.settings.keyboardShortcut || {})) });\n            resolve(mergedSettings);\n        });\n    });\n});\nexports.getSettings = getSettings;\n// Save settings to storage\nconst saveSettings = (settings) => __awaiter(void 0, void 0, void 0, function* () {\n    return new Promise((resolve) => {\n        chrome.storage.sync.set({ settings }, () => {\n            resolve();\n        });\n    });\n});\nexports.saveSettings = saveSettings;\n// Set an item in the cache\nconst setCacheItem = (key, data, expiryHours) => __awaiter(void 0, void 0, void 0, function* () {\n    const cacheItem = {\n        data,\n        timestamp: Date.now() + expiryHours * 60 * 60 * 1000,\n    };\n    yield chrome.storage.local.set({ [key]: cacheItem });\n});\nexports.setCacheItem = setCacheItem;\n// Get an item from the cache\nconst getCacheItem = (key) => __awaiter(void 0, void 0, void 0, function* () {\n    return new Promise((resolve) => {\n        chrome.storage.local.get(key, (result) => {\n            const cacheItem = result[key];\n            // If no cache or expired\n            if (!cacheItem || Date.now() > cacheItem.timestamp) {\n                resolve(null);\n                return;\n            }\n            resolve(cacheItem.data);\n        });\n    });\n});\nexports.getCacheItem = getCacheItem;\n// Clear expired cache items\nconst clearExpiredCache = () => __awaiter(void 0, void 0, void 0, function* () {\n    const allCache = (yield chrome.storage.local.get(null));\n    const now = Date.now();\n    const keysToRemove = [];\n    for (const [key, value] of Object.entries(allCache)) {\n        const cacheValue = value;\n        if (key.startsWith(\"cache_\") &&\n            cacheValue.timestamp &&\n            cacheValue.timestamp < now) {\n            keysToRemove.push(key);\n        }\n    }\n    if (keysToRemove.length > 0) {\n        yield chrome.storage.local.remove(keysToRemove);\n    }\n});\nexports.clearExpiredCache = clearExpiredCache;\n// Generate a cache key from text\nconst generateCacheKey = (text) => {\n    // Simple hash function for strings\n    let hash = 0;\n    if (text.length === 0)\n        return \"cache_empty\";\n    for (let i = 0; i < text.length; i++) {\n        const char = text.charCodeAt(i);\n        hash = (hash << 5) - hash + char;\n        hash = hash & hash; // Convert to 32bit integer\n    }\n    return `cache_${hash}`;\n};\nexports.generateCacheKey = generateCacheKey;\n// Debounce function to prevent too many API calls\nfunction debounce(func, waitFor) {\n    let timeout = null;\n    return function (...args) {\n        if (timeout !== null) {\n            clearTimeout(timeout);\n        }\n        timeout = setTimeout(() => func(...args), waitFor);\n    };\n}\n// Function to check if the text is valid for an explanation\nconst isValidText = (text) => {\n    if (!text)\n        return false;\n    text = text.trim();\n    return text.length > 0 && text.length <= 1000; // Arbitrary limit to prevent large requests\n};\nexports.isValidText = isValidText;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./src/background/index.ts\");\n",""],"names":[],"sourceRoot":""}